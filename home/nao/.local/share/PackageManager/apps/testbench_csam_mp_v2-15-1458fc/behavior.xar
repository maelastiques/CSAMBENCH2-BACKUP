<?xml version="1.0" encoding="UTF-8" ?><ChoregrapheProject xmlns="http://www.aldebaran-robotics.com/schema/choregraphe/project.xsd" xar_version="3"><Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s project. Highest level possible." x="0" y="0"><bitmap>media/images/box/root.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram scale="100"><Box name="Joint Init" id="1" localization="8" tooltip="This box is empty (contains a single motion layer with no motor position&#x0A;defined in it) and should be used to create any animation you would like." plugin="None" x="243" y="37"><bitmap>media/images/box/folder.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        #try:
        #  GeneratedClass.__init__(self, False)
        #except TypeError: # if NAOqi < 1.14
        GeneratedClass.__init__( self )
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)


    def onLoad(self):
        self.type = self.getParameter("TestBench_Type")

        self.joint_list = ["HeadPitch","HeadYaw","LShoulderPitch","RShoulderPitch","LShoulderRoll","RShoulderRoll","LElbowRoll","RElbowRoll","LElbowYaw","RElbowYaw","LWristYaw","RWristYaw","LHand","RHand","HipPitch","HipRoll","KneePitch","WheelB","WheelFL","WheelFR"]

        self.real_joint_value=[]

        for joint in self.joint_list:
            if self.getParameter(joint) == True:
                self.real_joint_value.append(joint)

        self.memory_proxy.insertData("testbench/config/list/joint_list", self.real_joint_value)
        self.memory_proxy.insertData("testbench/config/type", self.type)

    def onInput_onStart(self):
        #self.onStopped([0, 0, 0])
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="TestBench_Type" inherits_from_parent="0" content_type="3" value="CSAM" default_value="Head" custom_choice="0" tooltip="" id="5"><Choice value="CSAM" /><Choice value="T14" /><Choice value="Hand" /><Choice value="Hip" /><Choice value="Knee" /><Choice value="Elastomer" /><Choice value="Arm" /><Choice value="Head" /></Parameter><Parameter name="HeadPitch" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /><Parameter name="HeadYaw" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="7" /><Parameter name="RShoulderPitch" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="8" /><Parameter name="LShoulderPitch" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="9" /><Parameter name="RShoulderRoll" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="10" /><Parameter name="LShoulderRoll" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="11" /><Parameter name="RElbowRoll" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="12" /><Parameter name="LElbowRoll" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="13" /><Parameter name="RElbowYaw" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="14" /><Parameter name="LElbowYaw" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="15" /><Parameter name="RWristYaw" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="16" /><Parameter name="LWristYaw" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="17" /><Parameter name="RHand" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="18" /><Parameter name="LHand" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="19" /><Parameter name="HipPitch" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="20" /><Parameter name="HipRoll" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="21" /><Parameter name="KneePitch" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="22" /><Parameter name="WheelB" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="23" /><Parameter name="WheelFL" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="24" /><Parameter name="WheelFR" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="25" /><Timeline enable="1" fps="25" start_frame="1" end_frame="-1" size="-1"><BehaviorLayer name="Movement"><BehaviorKeyframe name="Movement" index="1"><Diagram scale="84.0896"><Box name="Check Type Move" id="4" localization="8" tooltip="Enter tooltip here" x="297" y="53"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

        self.memory_proxy.insertData('testbench/movement1/activity',True)
        self.memory_proxy.insertData('testbench/movement2/activity',False)

    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):

        #Recup etat mouvement
        self.movement1Activity = self.memory_proxy.getData('testbench/movement1/activity')
        self.movement2Activity = self.memory_proxy.getData('testbench/movement2/activity')

        if  self.movement2Activity :
            self.movement2()

        elif  self.movement1Activity :
            self.movement1()

        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="movement1" type="1" type_size="1" nature="2" inner="0" tooltip="" id="5" /><Output name="movement2" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /></Box><Box name="Cycle Movement" id="7" localization="8" tooltip="This box is empty and should be used to create any box diagram you would like.&#x0A;&#x0A;To edit its diagram, double-click on it." x="505" y="62"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Check Move1" id="1" localization="8" tooltip="Enter tooltip here" x="97" y="86"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)
        self.motion = ALProxy('ALMotion')

        #movement key
        self.move_key = 'testbench/movement1/inCycle'
        self.memory_proxy.insertData(self.move_key,False)

        self.cycle1_joint = ["LShoulderPitch","LShoulderRoll"]
        self.cycle2_joint = ["RShoulderPitch","RShoulderRoll"]
        self.cycle3_joint = []
        self.cycle4_joint = []
        self.cycle5_joint = []

        self.list_stiffness = [False]*5
        self.load = False
        self.list_secu_cycle = ['testbench/security/cyclage/cycle1','testbench/security/cyclage/cycle2',
        'testbench/security/cyclage/cycle3','testbench/security/cyclage/cycle4','testbench/security/cyclage/cycle5']
        map(self.memory_proxy.insertData, self.list_secu_cycle, [False]*len(self.list_secu_cycle))


    def onLoad(self):
        if not self.load:
            self.load = True
            #put initialization code here
            self.joint_list = self.memory_proxy.getData('testbench/config/list/joint_list')

            #suppression des doublon
            self.cycle1_joint = [ joint for joint in ["LShoulderPitch","LShoulderRoll"] for real_joint in self.joint_list if joint.find(real_joint) > -1]
            self.cycle2_joint = [ joint for joint in ["RShoulderPitch","RShoulderRoll"] for real_joint in self.joint_list if joint.find(real_joint) > -1]
            self.cycle3_joint = [ joint for joint in [] for real_joint in self.joint_list if join.find(real_joint) > -1]
            self.cycle4_joint = [ joint for joint in [] for real_joint in self.joint_list if join.find(real_joint) > -1]
            self.cycle5_joint = [ joint for joint in [] for real_joint in self.joint_list if join.find(real_joint) > -1]

        pass


    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #begining of movement see another box for flase value
        self.memory_proxy.insertData(self.move_key,True)
        for joint in self.joint_list:
            try:
                self.state_delta = self.memory_proxy.getData('testbench/security/delta/' + joint)
            except:
                self.state_delta = False
            try:
                self.state_temp = self.memory_proxy.getData('testbench/security/temp/' + joint)
            except:
                self.state_temp = False
            try:
                self.state_boot = self.memory_proxy.getData('testbench/security/bootloader/' + joint)
            except:
                self.state_boot = False

            #self.state_boot = self.memory_proxy.getData('testbench/security/boot/' + joint)
            if self.state_delta or self.state_temp or self.state_boot:
                self.memory_proxy.insertData('testbench/security/joint/' + joint + '/activation',False)
            else:
                self.memory_proxy.insertData('testbench/security/joint/' + joint + '/activation', True)

        try:
            self.target_flag = self.memory_proxy.getData("testbench/security/target_flag")

            if self.cycle1_joint:
                cycle_flag = False
                for cycle in self.cycle1_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if self.target_flag[0] == True:
                    cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[0]:
                        self.stiffness_OFF(self.cycle1_joint)
                        self.list_stiffness[0] = False
                        self.set_secu_cycle(0,False)
                    self.cycle1_Joint_Inactive()
                else:
                    if not self.list_stiffness[0]:
                        self.stiffness_ON(self.cycle1_joint)
                        self.list_stiffness[0] = True
                        self.set_secu_cycle(0,True)
                    self.cycle1_Joint_Active()
            else:
                self.cycle1_Joint_Inactive()

            if  self.cycle2_joint:
                cycle_flag = False
                for cycle in self.cycle2_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if self.target_flag[1] == True:
                    cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[1]:
                        self.stiffness_OFF(self.cycle2_joint)
                        self.set_secu_cycle(1,False)
                        self.list_stiffness[1] = False
                    self.cycle2_Joint_Inactive()
                else:
                    if not self.list_stiffness[1]:
                        self.stiffness_ON(self.cycle2_joint)
                        self.list_stiffness[1] = True
                        self.set_secu_cycle(1,True)
                    self.cycle2_Joint_Active()
            else:
                self.cycle2_Joint_Inactive()

            if  self.cycle3_joint:
                cycle_flag = False
                for cycle in self.cycle3_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if self.target_flag[2] == True:
                    cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[2]:
                        self.stiffness_OFF(self.cycle3_joint)
                        self.list_stiffness[2] = False
                        self.set_secu_cycle(2,False)
                    self.cycle3_Joint_Inactive()
                else:
                    if not self.list_stiffness[2]:
                        self.stiffness_ON(self.cycle3_joint)
                        self.list_stiffness[2] = True
                        self.set_secu_cycle(2,True)
                    self.cycle3_Joint_Active()
            else:
                self.cycle3_Joint_Inactive()

            if  self.cycle4_joint:
                cycle_flag = False
                for cycle in self.cycle4_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if self.target_flag[3] == True:
                    cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[3]:
                        self.stiffness_OFF(self.cycle4_joint)
                        self.list_stiffness[3] = False
                        self.set_secu_cycle(3,False)
                    self.cycle4_Joint_Inactive()
                else:
                    if not self.list_stiffness[3]:
                        self.stiffness_ON(self.cycle4_joint)
                        self.list_stiffness[3] = True
                        self.set_secu_cycle(3,True)
                    self.cycle4_Joint_Active()
            else:
                self.cycle4_Joint_Inactive()

            if  self.cycle5_joint:
                cycle_flag = False
                for cycle in self.cycle5_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if self.target_flag[4] == True:
                    cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[4]:
                        self.stiffness_OFF(self.cycle5_joint)
                        self.list_stiffness[4] = False
                        self.set_secu_cycle(4,False)
                    self.cycle5_Joint_Inactive()
                else:
                    if not self.list_stiffness[4]:
                        self.stiffness_ON(self.cycle5_joint)
                        self.list_stiffness[4] = True
                        self.set_secu_cycle(4,True)
                    self.cycle5_Joint_Active()
            else:
                self.cycle5_Joint_Inactive()
        except:
            if self.cycle1_joint:
                cycle_flag = False
                for cycle in self.cycle1_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[0]:
                        self.stiffness_OFF(self.cycle1_joint)
                        self.list_stiffness[0] = False
                        self.set_secu_cycle(0,False)
                    self.cycle1_Joint_Inactive()
                else:
                    if not self.list_stiffness[0]:
                        self.stiffness_ON(self.cycle1_joint)
                        self.list_stiffness[0] = True
                        self.set_secu_cycle(0,True)
                    self.cycle1_Joint_Active()
            else:
                self.cycle1_Joint_Inactive()

            if  self.cycle2_joint:
                cycle_flag = False
                for cycle in self.cycle2_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[1]:
                        self.stiffness_OFF(self.cycle2_joint)
                        self.set_secu_cycle(1,False)
                        self.list_stiffness[1] = False
                    self.cycle2_Joint_Inactive()
                else:
                    if not self.list_stiffness[1]:
                        self.stiffness_ON(self.cycle2_joint)
                        self.list_stiffness[1] = True
                        self.set_secu_cycle(1,True)
                    self.cycle2_Joint_Active()
            else:
                self.cycle2_Joint_Inactive()

            if  self.cycle3_joint:
                cycle_flag = False
                for cycle in self.cycle3_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[2]:
                        self.stiffness_OFF(self.cycle3_joint)
                        self.list_stiffness[2] = False
                        self.set_secu_cycle(2,False)
                    self.cycle3_Joint_Inactive()
                else:
                    if not self.list_stiffness[2]:
                        self.stiffness_ON(self.cycle3_joint)
                        self.list_stiffness[2] = True
                        self.set_secu_cycle(2,True)
                    self.cycle3_Joint_Active()
            else:
                self.cycle3_Joint_Inactive()

            if  self.cycle4_joint:
                cycle_flag = False
                for cycle in self.cycle4_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[3]:
                        self.stiffness_OFF(self.cycle4_joint)
                        self.list_stiffness[3] = False
                        self.set_secu_cycle(3,False)
                    self.cycle4_Joint_Inactive()
                else:
                    if not self.list_stiffness[3]:
                        self.stiffness_ON(self.cycle4_joint)
                        self.list_stiffness[3] = True
                        self.set_secu_cycle(3,True)
                    self.cycle4_Joint_Active()
            else:
                self.cycle4_Joint_Inactive()

            if  self.cycle5_joint:
                cycle_flag = False
                for cycle in self.cycle5_joint:
                    if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                        cycle_flag = True
                if cycle_flag:
                    if self.list_stiffness[4]:
                        self.stiffness_OFF(self.cycle5_joint)
                        self.list_stiffness[4] = False
                        self.set_secu_cycle(4,False)
                    self.cycle5_Joint_Inactive()
                else:
                    if not self.list_stiffness[4]:
                        self.stiffness_ON(self.cycle5_joint)
                        self.list_stiffness[4] = True
                        self.set_secu_cycle(4,True)
                    self.cycle5_Joint_Active()
            else:
                self.cycle5_Joint_Inactive()


        #self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped

    def stiffness_ON(self, list_join):
        for joint in list_join:
            self.motion.stiffnessInterpolation(joint, 1.0, 1.0)

    def stiffness_OFF(self, list_join):
        for joint in list_join:
            self.motion.stiffnessInterpolation(joint, 0.0, 1.0)
    def set_secu_cycle(self, index, bool):
        self.memory_proxy.insertData(self.list_secu_cycle[index], bool)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="cycle1_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="5" /><Output name="cycle1_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /><Output name="cycle2_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="7" /><Output name="cycle2_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="8" /><Output name="cycle3_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="9" /><Output name="cycle3_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="10" /><Output name="cycle4_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="11" /><Output name="cycle4_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="12" /><Output name="cycle5_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="13" /><Output name="cycle5_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="14" /></Box><Box name="Wait + Cycle count" id="2" localization="8" tooltip="This box is empty and should be used to create any box script you would like.&#x0A;&#x0A;To edit its script, double-click on it." x="642" y="70"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[import  datetime
import re
from os import rename, listdir, path, mkdir
class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        self.move_key = 'testbench/movement1/inCycle'

        #list for file name presence
        self.list_filname = []

        #list of presence
        self.presence = [False] *5
        self.load = False

        self.message0 = False
        self.message1 = False
        self.message2 = False
        self.message3 = False
        self.message4 = False
        pass

    def onLoad(self):
        [self.filename1,self.filename2,self.filename3,self.filename4,self.filename5] = map(self.getParameter ,
            ["Cycle1_Filename","Cycle2_Filename","Cycle3_Filename","Cycle4_Filename","Cycle5_Filename"])

        for file_name in [self.filename1,self.filename2,self.filename3,self.filename4,self.filename5]:
            if file_name:
                self.list_filname.append(file_name)
            else:
                self.list_filname.append(None)


        if not self.load:
            self.load = True
            self.max_length_file = 10000
            #creation of path
            self.path = self.mem.getData('testbench/config/log/cycle/path')
            if not path.exists(self.path):
                mkdir(self.path)

            #creation list of cycle for each cycle filename
            self.cycle_list = map(self.recup_last_count, [self.path]*len(self.list_filname), self.list_filname)

            #create files
            self.list_full_filename = map(self.create_file, [self.path]*len(self.list_filname), self.list_filname, self.cycle_list)

            #create list of length of file
            self.file_length_list = map(self.length_file, self.list_full_filename)

        self.target()
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self):
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is recommended to call onUnload of this box in a onStop method, as the code written in onUnload is used to stop the box as well
        pass

    def onInput_Cycle1_On(self):
        self.presence[0] = True
        self.increment_counter(0)
        self.out()

    def onInput_Cycle1_Off(self):
        self.presence[0] = True
        self.out()

    def onInput_Cycle2_On(self):
        self.presence[1] = True
        self.increment_counter(1)
        self.out()

    def onInput_Cycle2_Off(self):
        self.presence[1] = True
        self.out()

    def onInput_Cycle3_On(self):
        self.presence[2] = True
        self.increment_counter(2)
        self.out()

    def onInput_Cycle3_Off(self):
        self.presence[2] = True
        self.out()

    def onInput_Cycle4_On(self):
        self.presence[3] = True
        self.increment_counter(3)
        self.out()

    def onInput_Cycle4_Off(self):
        self.presence[3] = True
        self.out()

    def onInput_Cycle5_On(self):
        self.presence[4] = True
        self.increment_counter(4)
        self.out()

    def onInput_Cycle5_Off(self):
        self.presence[4] = True
        self.out()

    def out(self):
        default = [presence for presence in self.presence if not presence]
        if not default :
            self.presence = [False] * 5
            #end of the movement
            self.mem.insertData(self.move_key,False)
            self.onStopped()

    def file_verification(self, path):
        #open file
        with open(path,'r') as fichier:
            new = []
            old = fichier.readlines()
            default = False
            compilation = re.compile(r"^(\d){4}(-(\d){2}){2} (\d){2}(:(\d){2}){2};\d*\n$")

            for index, line in enumerate(old):
                if not index:
                    new.append(line)
                else:
                    if compilation.match(line) and not default:
                        new.append(line)
                    else:
                        default = True
        if default:
            rename(path,path.replace('.csv','_old.csv'))
            with open(path, 'w') as fichier:
                fichier.writelines(new)

    def length_file(self, path):
        if path is not None:
            with open(path) as fichier:
                count = len(fichier.readlines())
            return count
        return 0

    def recup_last_count(self, folder, filt):
        """
        Récupération du dernier compteur valide
        """

        #Filtre obligatoire
        if filt == "" or filt is None:
            print ('Filtre incorrect')
            return None

        if not os.path.exists(folder):
            print("Dossier \"%s\" non trouve" % folder)
            return None

        #initialisation des compteurs
        count = None
        c_fichier = 0

        #recherche des fichiers
        list_fichier = [fichier for fichier in os.listdir(folder) if
            fichier.find("_old") == -1 and fichier.find(filt) > -1 and
            fichier.find("~") == -1]

        list_fichier.sort(reverse=True)

        #Début de la recherche
        while count is None and c_fichier < len(list_fichier):
            try:
            #ouverture de chaque fichier
                with open(os.path.join(folder, list_fichier[c_fichier]),
                        'r') as cur_file:

                    cur_data = cur_file.readlines()
                    cur_line = 1
                    while cur_line < len(cur_data) and count is None:
                        #recupération de la dernière ligne
                        if len(cur_data) > 1:
                            #essai pour chaque ligne
                            try:
                                int(cur_data[-cur_line].split(";")[-1][:-1])
                                count = int(cur_data[-cur_line].split(";")[-1][:-1])
                            except:
                                pass

                        cur_line += 1

            except:
                print(("Ouverture du fichier \"%s\" impossible" %
                    list_fichier[c_fichier]))

            finally:
                c_fichier += 1
        if count is None:
            count = 0
        return count

    def create_file(self, folder, filename, count=0):
        if filename is None:
            return None

        date = datetime.datetime.now().strftime("%Y-%m-%d_%Hh%Mm")
        date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        first_line = ";".join(["Date","count\n"])
        second_line = ";".join([date_log,str(count)+"\n"])
        filename = path.join(self.path, "_".join([date,filename+".csv"]))

        with open(filename , "w") as fichier:
            fichier.writelines([first_line,second_line])
        return filename

    def increment_counter(self, index):
        #inc counter
        if self.file_length_list[index] >= self.max_length_file:
            self.list_full_filename[index] = self.create_file(self.path, self.list_filname[index], self.cycle_list[index])
            self.file_length_list[index] = 2
        self.cycle_list[index] += 1
        self.file_length_list[index] += 1
        with open(self.list_full_filename[index], 'a') as fichier:
            date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            fichier.write(";".join([date_log,str(self.cycle_list[index])+"\n"]))
            self.mem.insertData("Cycle_" + self.list_filname[index], self.cycle_list[index])

    def target(self):
        self.ActivationTarget = self.mem.getData("testbench/config/target/activation")
        self.TargetValue1 = int(self.mem.getData("testbench/config/Target/Value1"))
        self.TargetValue2 = int(self.mem.getData("testbench/config/Target/Value2"))
        self.TargetValue3 = int(self.mem.getData("testbench/config/Target/Value3"))
        self.TargetValue4 = int(self.mem.getData("testbench/config/Target/Value4"))
        self.TargetValue5 = int(self.mem.getData("testbench/config/Target/Value5"))


        if self.ActivationTarget:
            self.target_flag = [False] *5

            if self.cycle_list[0] >= self.TargetValue1:
                self.target_flag[0] = True
                if self.message0 == False:
                    joint = self.list_filname[0]
                    self.output2(joint)
                    self.message0 = True

            if self.cycle_list[1] >= self.TargetValue2:
                self.target_flag[1] = True
                if self.message1 == False:
                    joint = self.list_filname[1]
                    self.output2(joint)
                    self.message1 = True

            if self.cycle_list[2] >= self.TargetValue3:
                self.target_flag[2] = True
                if self.message2 == False:
                    joint = self.list_filname[2]
                    self.output2(joint)
                    self.message2 = True

            if self.cycle_list[3] >= self.TargetValue4:
                self.target_flag[3] = True
                if self.message3 == False:
                    joint = self.list_filname[3]
                    self.output2(joint)
                    self.message3 = True

            if self.cycle_list[4] >= self.TargetValue5:
                self.target_flag[4] = True
                if self.message4 == False:
                    joint = self.list_filname[4]
                    self.output2(joint)
                    self.message4 = True

            self.mem.insertData("testbench/security/target_flag", self.target_flag)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Input name="Cycle1_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="4" /><Input name="Cycle1_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="5" /><Input name="Cycle2_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="6" /><Input name="Cycle2_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="7" /><Input name="Cycle3_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="8" /><Input name="Cycle3_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="9" /><Input name="Cycle4_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="10" /><Input name="Cycle4_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="11" /><Input name="Cycle5_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="12" /><Input name="Cycle5_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="13" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="14" /><Output name="output2" type="0" type_size="1" nature="2" inner="0" tooltip="" id="15" /><Parameter name="Cycle1_Filename" inherits_from_parent="0" content_type="3" value="Lcsam" default_value="" custom_choice="0" tooltip="" id="16" /><Parameter name="Cycle2_Filename" inherits_from_parent="0" content_type="3" value="Rcsam" default_value="" custom_choice="0" tooltip="" id="17" /><Parameter name="Cycle3_Filename" inherits_from_parent="0" content_type="3" value="" default_value="" custom_choice="0" tooltip="" id="18" /><Parameter name="Cycle4_Filename" inherits_from_parent="0" content_type="3" value="" default_value="" custom_choice="0" tooltip="" id="19" /><Parameter name="Cycle5_Filename" inherits_from_parent="0" content_type="3" value="" default_value="" custom_choice="0" tooltip="" id="20" /></Box><Box name="LCSAM_MP" id="3" localization="8" tooltip="Enter tooltip here" x="362" y="67"><bitmap>media/images/box/movement/animation_mode.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")

    def onLoad(self):
        self.test_speed = self.getParameter("Speed")
        self.pause_time = self.getParameter("Pause")
        self.test_speed_AR = self.getParameter("Speed_AR")
        self.joints_list = ["LShoulderPitch","LShoulderRoll"]
        self._positions = []
        self._positions_AR = []
        self._cycle = 0


        #Position
        self.position_1 = [ -1.894, 1.387]
        self.position_2 = [ -0.389, 0.91]
        self.position_3 = [-1.136, 1.15]
        self.position_4 = [0.389, 0.67]
        self.position_5 = [-0.389, 0.91]
        self.position_6 = [ 1.136, 0.44]
        self.position_7 = [ 0.389, 0.67]
        self.position_8 = [ 1.894, 0.2]
        self.position_9 = [ -1.894, 1.387]
        self.position_10 = [ 1.392, -0.174]
        self.position_11 = [1.309, 0.2]
        self.position_12 = [1.392, -0.174]
        self.position_13 = [1.309, 0.2]
        self.position_14 = [ 1.392, -0.174]
        self.position_15 = [ 1.309, 0.2]
        self.position_16 = [ 1.894, -0.174]

        #Make position
        self._positions.append(self.position_1)
        self._positions.append(self.position_2)
        self._positions.append(self.position_3)
        self._positions.append(self.position_4)
        self._positions.append(self.position_5)
        self._positions.append(self.position_6)
        self._positions.append(self.position_7)
        self._positions.append(self.position_8)
        self._positions.append(self.position_9)
        self._positions.append(self.position_10)
        self._positions_AR.append(self.position_11)
        self._positions_AR.append(self.position_12)
        self._positions_AR.append(self.position_13)
        self._positions_AR.append(self.position_14)
        self._positions_AR.append(self.position_15)
        self._positions_AR.append(self.position_16)

        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.stiffness_ON()
        for position in self._positions:
            self.motion.angleInterpolationWithSpeed(self.joints_list, position, self.test_speed)

        for positionAR in self._positions_AR:
            self.motion.angleInterpolationWithSpeed(self.joints_list, positionAR, self.test_speed_AR)


        self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Speed" inherits_from_parent="0" content_type="2" value="0.5" default_value="0" min="0" max="1" tooltip="" id="5" /><Parameter name="Pause" inherits_from_parent="0" content_type="2" value="0" default_value="0" min="0" max="10" tooltip="" id="6" /><Parameter name="Speed_AR" inherits_from_parent="0" content_type="2" value="0.2" default_value="0" min="0" max="1" tooltip="" id="7" /></Box><Box name="RCSAM_MP" id="6" localization="8" tooltip="Enter tooltip here" x="362" y="182"><bitmap>media/images/box/movement/animation_mode.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

        self.motion = ALProxy("ALMotion")

    def onLoad(self):
        self.test_speed = self.getParameter("Speed")
        self.pause_time = self.getParameter("Pause")
        self.test_speed_AR = self.getParameter("Speed_AR")
        self.joints_list = ["RShoulderPitch","RShoulderRoll"]
        self._positions = []
        self._positions_AR = []
        self._cycle = 0


        #Position
        self.position_1 = [ -1.894, -1.387]
        self.position_2 = [ -0.389, -0.91]
        self.position_3 = [-1.136, -1.15]
        self.position_4 = [0.389, -0.67]
        self.position_5 = [-0.389, -0.91]
        self.position_6 = [ 1.136, -0.44]
        self.position_7 = [ 0.389, -0.67]
        self.position_8 = [ 1.894, -0.2]
        self.position_9 = [ -1.894, -1.387]
        self.position_10 = [ 1.392, 0.174]
        self.position_11 = [1.309, -0.2]
        self.position_12 = [1.392, 0.174]
        self.position_13 = [1.309, -0.2]
        self.position_14 = [ 1.392, 0.174]
        self.position_15 = [ 1.309, -0.2]
        self.position_16 = [ 1.894, 0.174]

        #Make position
        self._positions.append(self.position_1)
        self._positions.append(self.position_2)
        self._positions.append(self.position_3)
        self._positions.append(self.position_4)
        self._positions.append(self.position_5)
        self._positions.append(self.position_6)
        self._positions.append(self.position_7)
        self._positions.append(self.position_8)
        self._positions.append(self.position_9)
        self._positions.append(self.position_10)
        self._positions_AR.append(self.position_11)
        self._positions_AR.append(self.position_12)
        self._positions_AR.append(self.position_13)
        self._positions_AR.append(self.position_14)
        self._positions_AR.append(self.position_15)
        self._positions_AR.append(self.position_16)

        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.stiffness_ON()
        for position in self._positions:
            self.motion.angleInterpolationWithSpeed(self.joints_list, position, self.test_speed)

        for positionAR in self._positions_AR:
            self.motion.angleInterpolationWithSpeed(self.joints_list, positionAR, self.test_speed_AR)

        self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Speed" inherits_from_parent="0" content_type="2" value="0.5" default_value="0" min="0" max="1" tooltip="" id="5" /><Parameter name="Pause" inherits_from_parent="0" content_type="2" value="0" default_value="0" min="0" max="10" tooltip="" id="6" /><Parameter name="Speed_AR" inherits_from_parent="0" content_type="2" value="0.2" default_value="0" min="0" max="1" tooltip="" id="7" /></Box><Box name="Event" id="10" localization="8" tooltip="Enter tooltip here" x="823" y="202"><bitmap>media/images/box/interaction/text_read.png</bitmap><script language="4"><content><![CDATA[import socket
import threading
import os
import time
import sys
import pickle

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        self.sys = ALProxy("ALSystem")
        self.host = '10.0.160.106'
        self.port = 51080
        self.flagDefault = False
        self.i = 0
        pass

    def onLoad(self):
        self.type = self.mem.getData("testbench/config/type")
        self.messages_a_envoyer = []
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, message):
        self.socket(message)
        pass

    def onInput_onStop(self):
        self.onUnload()
        pass

    def socket(self, message):
        self.messages_a_envoyer=[]

        self.connexion = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        while self.i<11:
            try:
                self.connexion.connect((self.host, self.port))
                print "Connexion etablie avec le serveur."
                self.flagDefault = True
            except socket.error:
                print "la connexion à echoue."
                self.flagDefault = False
                pass


            if self.flagDefault == True:
                date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                self.type = self.mem.getData("testbench/config/type")

                self.messages_a_envoyer.append(date_log)
                self.messages_a_envoyer.append(self.type)
                self.messages_a_envoyer.append(self.sys.robotName())
                self.messages_a_envoyer.append(message)

                self.message_emis = self.messages_a_envoyer
                msg = "target"
                self.connexion.send(msg)
                self.message_recut = self.connexion.recv(255)
                print self.message_recut

                if self.message_recut == 'Ok pour target':
                    data = pickle.dumps(self.message_emis)
                    print self.message_emis
                    self.connexion.send(data)
                self.connexion.close()
                self.i=11
            elif self.flagDefault == False:
                self.i = self.i + 1
        self.i = 0]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Parameter name="Message" inherits_from_parent="0" content_type="3" value="Motor hot" default_value="Message to send" custom_choice="0" tooltip="" id="4" /></Box><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="2" indexofinput="5" outputowner="1" indexofoutput="6" /><Link inputowner="2" indexofinput="7" outputowner="1" indexofoutput="8" /><Link inputowner="2" indexofinput="9" outputowner="1" indexofoutput="10" /><Link inputowner="2" indexofinput="11" outputowner="1" indexofoutput="12" /><Link inputowner="2" indexofinput="13" outputowner="1" indexofoutput="14" /><Link inputowner="0" indexofinput="4" outputowner="2" indexofoutput="14" /><Link inputowner="3" indexofinput="2" outputowner="1" indexofoutput="5" /><Link inputowner="6" indexofinput="2" outputowner="1" indexofoutput="7" /><Link inputowner="2" indexofinput="4" outputowner="3" indexofoutput="4" /><Link inputowner="2" indexofinput="6" outputowner="6" indexofoutput="4" /><Link inputowner="10" indexofinput="2" outputowner="2" indexofoutput="15" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Wait" id="1" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="79" y="14"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="1" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Box name="Wait" id="2" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="740" y="157"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="0.5" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Box name="Carac" id="3" localization="8" tooltip="This box is empty and should be used to create any box diagram you would like.&#x0A;&#x0A;To edit its diagram, double-click on it." x="515" y="154"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Check Move2" id="2" localization="8" tooltip="Enter tooltip here" x="202" y="113"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)
        self.motion = ALProxy('ALMotion')

        #movement key
        self.move_key = 'testbench/movement2/inCycle'
        self.memory_proxy.insertData(self.move_key,False)

        self.cycle1_joint = ["LShoulderPitch","LShoulderRoll"]
        self.cycle2_joint = ["RShoulderPitch","RShoulderRoll"]
        self.cycle3_joint = []
        self.cycle4_joint = []
        self.cycle5_joint = []

        self.list_stiffness = [False]*5
        self.load = False
        self.list_secu_cycle = ['testbench/security/cyclage/cycle1','testbench/security/cyclage/cycle2',
        'testbench/security/cyclage/cycle3','testbench/security/cyclage/cycle4','testbench/security/cyclage/cycle5']
        map(self.memory_proxy.insertData, self.list_secu_cycle, [False]*len(self.list_secu_cycle))


    def onLoad(self):
        if not self.load:
            self.load = True
            #put initialization code here
            self.joint_list = self.memory_proxy.getData('testbench/config/list/joint_list')

            #suppression des doublon
            self.cycle1_joint = [ joint for joint in ["LShoulderPitch","LShoulderRoll"] for real_joint in self.joint_list if joint.find(real_joint) > -1]
            self.cycle2_joint = [ joint for joint in ["RShoulderPitch","RShoulderRoll"] for real_joint in self.joint_list if joint.find(real_joint) > -1]
            self.cycle3_joint = [ joint for joint in [] for real_joint in self.joint_list if join.find(real_joint) > -1]
            self.cycle4_joint = [ joint for joint in [] for real_joint in self.joint_list if join.find(real_joint) > -1]
            self.cycle5_joint = [ joint for joint in [] for real_joint in self.joint_list if join.find(real_joint) > -1]

        pass


    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #begining of movement see another box for flase value
        self.memory_proxy.insertData(self.move_key,True)
        #disabled temperature warning
        for joint in self.joint_list:
            self.state_delta = self.memory_proxy.getData('testbench/security/delta/' + joint)
            if self.state_delta:
                self.memory_proxy.insertData('testbench/security/joint/' + joint + '/activation',False)
            else:
                self.memory_proxy.insertData('testbench/security/joint/' + joint + '/activation', True)

        if self.cycle1_joint:
            cycle_flag = False
            for cycle in self.cycle1_joint:
                if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                    cycle_flag = True
            if cycle_flag:
                if self.list_stiffness[0]:
                    self.stiffness_OFF(self.cycle1_joint)
                    self.list_stiffness[0] = False
                    self.set_secu_cycle(0,False)
                self.cycle1_Joint_Inactive()
            else:
                if not self.list_stiffness[0]:
                    self.stiffness_ON(self.cycle1_joint)
                    self.list_stiffness[0] = True
                    self.set_secu_cycle(0,True)
                self.cycle1_Joint_Active()
        else:
            self.cycle1_Joint_Inactive()

        if  self.cycle2_joint:
            cycle_flag = False
            for cycle in self.cycle2_joint:
                if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                    cycle_flag = True
            if cycle_flag:
                if self.list_stiffness[1]:
                    self.stiffness_OFF(self.cycle2_joint)
                    self.set_secu_cycle(1,False)
                    self.list_stiffness[1] = False
                self.cycle2_Joint_Inactive()
            else:
                if not self.list_stiffness[1]:
                    self.stiffness_ON(self.cycle2_joint)
                    self.list_stiffness[1] = True
                    self.set_secu_cycle(1,True)
                self.cycle2_Joint_Active()
        else:
            self.cycle2_Joint_Inactive()

        if  self.cycle3_joint:
            cycle_flag = False
            for cycle in self.cycle3_joint:
                if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                    cycle_flag = True
            if cycle_flag:
                if self.list_stiffness[2]:
                    self.stiffness_OFF(self.cycle3_joint)
                    self.list_stiffness[2] = False
                    self.set_secu_cycle(2,False)
                self.cycle3_Joint_Inactive()
            else:
                if not self.list_stiffness[2]:
                    self.stiffness_ON(self.cycle3_joint)
                    self.list_stiffness[2] = True
                    self.set_secu_cycle(2,True)
                self.cycle3_Joint_Active()
        else:
            self.cycle3_Joint_Inactive()

        if  self.cycle4_joint:
            cycle_flag = False
            for cycle in self.cycle4_joint:
                if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                    cycle_flag = True
            if cycle_flag:
                if self.list_stiffness[3]:
                    self.stiffness_OFF(self.cycle4_joint)
                    self.list_stiffness[3] = False
                    self.set_secu_cycle(3,False)
                self.cycle4_Joint_Inactive()
            else:
                if not self.list_stiffness[3]:
                    self.stiffness_ON(self.cycle4_joint)
                    self.list_stiffness[3] = True
                    self.set_secu_cycle(3,True)
                self.cycle4_Joint_Active()
        else:
            self.cycle4_Joint_Inactive()

        if  self.cycle5_joint:
            cycle_flag = False
            for cycle in self.cycle5_joint:
                if not self.memory_proxy.getData('testbench/security/joint/' + cycle + '/activation'):
                    cycle_flag = True
            if cycle_flag:
                if self.list_stiffness[4]:
                    self.stiffness_OFF(self.cycle5_joint)
                    self.list_stiffness[4] = False
                    self.set_secu_cycle(4,False)
                self.cycle5_Joint_Inactive()
            else:
                if not self.list_stiffness[4]:
                    self.stiffness_ON(self.cycle5_joint)
                    self.list_stiffness[4] = True
                    self.set_secu_cycle(4,True)
                self.cycle5_Joint_Active()
        else:
            self.cycle5_Joint_Inactive()


        #self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped

    def stiffness_ON(self, list_join):
        for joint in list_join:
            self.motion.stiffnessInterpolation(joint, 1.0, 1.0)

    def stiffness_OFF(self, list_join):
        for joint in list_join:
            self.motion.stiffnessInterpolation(joint, 0.0, 1.0)
    def set_secu_cycle(self, index, bool):
        self.memory_proxy.insertData(self.list_secu_cycle[index], bool)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="cycle1_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="5" /><Output name="cycle1_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /><Output name="cycle2_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="7" /><Output name="cycle2_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="8" /><Output name="cycle3_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="9" /><Output name="cycle3_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="10" /><Output name="cycle4_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="11" /><Output name="cycle4_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="12" /><Output name="cycle5_Joint_Active" type="1" type_size="1" nature="2" inner="0" tooltip="" id="13" /><Output name="cycle5_Joint_Inactive" type="1" type_size="1" nature="2" inner="0" tooltip="" id="14" /></Box><Box name="Wait + Cycle count" id="4" localization="8" tooltip="This box is empty and should be used to create any box script you would like.&#x0A;&#x0A;To edit its script, double-click on it." x="747" y="97"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[import  datetime
import re
from os import rename, listdir, path, mkdir
class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        self.move_key = 'testbench/movement2/inCycle'
        self.presence = [False] *5
        self.load = False
        pass

    def onLoad(self):

        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self):
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is recommended to call onUnload of this box in a onStop method, as the code written in onUnload is used to stop the box as well
        pass

    def onInput_Cycle1_On(self):
        self.presence[0] = True
        #self.increment_counter(0)
        self.out()

    def onInput_Cycle1_Off(self):
        self.presence[0] = True
        self.out()

    def onInput_Cycle2_On(self):
        self.presence[1] = True
        #self.increment_counter(1)
        self.out()

    def onInput_Cycle2_Off(self):
        self.presence[1] = True
        self.out()

    def onInput_Cycle3_On(self):
        self.presence[2] = True
        #self.increment_counter(2)
        self.out()

    def onInput_Cycle3_Off(self):
        self.presence[2] = True
        self.out()

    def onInput_Cycle4_On(self):
        self.presence[3] = True
        #self.increment_counter(3)
        self.out()

    def onInput_Cycle4_Off(self):
        self.presence[3] = True
        self.out()

    def onInput_Cycle5_On(self):
        self.presence[4] = True
        #self.increment_counter(4)
        self.out()

    def onInput_Cycle5_Off(self):
        self.presence[4] = True
        self.out()

    def out(self):
        default = [presence for presence in self.presence if not presence]
        if not default :
            self.presence = [False] * 5
            #end of the movement
            self.mem.insertData(self.move_key,False)
            self.onStopped()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Input name="Cycle1_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="4" /><Input name="Cycle1_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="5" /><Input name="Cycle2_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="6" /><Input name="Cycle2_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="7" /><Input name="Cycle3_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="8" /><Input name="Cycle3_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="9" /><Input name="Cycle4_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="10" /><Input name="Cycle4_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="11" /><Input name="Cycle5_On" type="1" type_size="1" nature="1" inner="0" tooltip="" id="12" /><Input name="Cycle5_Off" type="1" type_size="1" nature="1" inner="0" tooltip="" id="13" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="14" /><Parameter name="Cycle1_Filename" inherits_from_parent="0" content_type="3" value="Lcsam" default_value="" custom_choice="0" tooltip="" id="15" /><Parameter name="Cycle2_Filename" inherits_from_parent="0" content_type="3" value="Rcsam" default_value="" custom_choice="0" tooltip="" id="16" /><Parameter name="Cycle3_Filename" inherits_from_parent="0" content_type="3" value="" default_value="" custom_choice="0" tooltip="" id="17" /><Parameter name="Cycle4_Filename" inherits_from_parent="0" content_type="3" value="" default_value="" custom_choice="0" tooltip="" id="18" /><Parameter name="Cycle5_Filename" inherits_from_parent="0" content_type="3" value="" default_value="" custom_choice="0" tooltip="" id="19" /></Box><Box name="LCSAM_MP" id="3" localization="8" tooltip="Enter tooltip here" x="454" y="89"><bitmap>media/images/box/movement/animation_mode.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.motion = ALProxy("ALMotion")

    def onLoad(self):
        self.test_speed = self.getParameter("Speed")
        self.pause_time = self.getParameter("Pause")
        self.test_speed_AR = self.getParameter("Speed_AR")
        self.joints_list = ["LShoulderPitch","LShoulderRoll"]
        self._positions = []
        self._positions_AR = []
        self._cycle = 0


        #Position
        self.position_1 = [ -1.894, 1.387]
        self.position_2 = [ -0.389, 0.91]
        self.position_3 = [-1.136, 1.15]
        self.position_4 = [0.389, 0.67]
        self.position_5 = [-0.389, 0.91]
        self.position_6 = [ 1.136, 0.44]
        self.position_7 = [ 0.389, 0.67]
        self.position_8 = [ 1.894, 0.2]
        self.position_9 = [ -1.894, 1.387]
        self.position_10 = [ 1.392, 0.174]
        self.position_11 = [1.309, 0.2]
        self.position_12 = [1.392, 0.174]
        self.position_13 = [1.309, 0.2]
        self.position_14 = [ 1.392, 0.174]
        self.position_15 = [ 1.309, 0.2]
        self.position_16 = [ 1.894, 0.174]

        #Make position
        self._positions.append(self.position_1)
        self._positions.append(self.position_2)
        self._positions.append(self.position_3)
        self._positions.append(self.position_4)
        self._positions.append(self.position_5)
        self._positions.append(self.position_6)
        self._positions.append(self.position_7)
        self._positions.append(self.position_8)
        self._positions.append(self.position_9)
        self._positions.append(self.position_10)
        self._positions_AR.append(self.position_11)
        self._positions_AR.append(self.position_12)
        self._positions_AR.append(self.position_13)
        self._positions_AR.append(self.position_14)
        self._positions_AR.append(self.position_15)
        self._positions_AR.append(self.position_16)

        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.stiffness_ON()
        for position in self._positions:
            self.motion.angleInterpolationWithSpeed(self.joints_list, position, self.test_speed)

        for positionAR in self._positions_AR:
            self.motion.angleInterpolationWithSpeed(self.joints_list, positionAR, self.test_speed_AR)


        self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Speed" inherits_from_parent="0" content_type="2" value="0.5" default_value="0" min="0" max="1" tooltip="" id="5" /><Parameter name="Pause" inherits_from_parent="0" content_type="2" value="0" default_value="0" min="0" max="10" tooltip="" id="6" /><Parameter name="Speed_AR" inherits_from_parent="0" content_type="2" value="0.2" default_value="0" min="0" max="1" tooltip="" id="7" /></Box><Box name="RCSAM_MP" id="6" localization="8" tooltip="Enter tooltip here" x="454" y="204"><bitmap>media/images/box/movement/animation_mode.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

        self.motion = ALProxy("ALMotion")

    def onLoad(self):
        self.test_speed = self.getParameter("Speed")
        self.pause_time = self.getParameter("Pause")
        self.test_speed_AR = self.getParameter("Speed_AR")
        self.joints_list = ["RShoulderPitch","RShoulderRoll"]
        self._positions = []
        self._positions_AR = []
        self._cycle = 0


        #Position
        self.position_1 = [ -1.894, -1.387]
        self.position_2 = [ -0.389, -0.91]
        self.position_3 = [-1.136, -1.15]
        self.position_4 = [0.389, -0.67]
        self.position_5 = [-0.389, -0.91]
        self.position_6 = [ 1.136, -0.44]
        self.position_7 = [ 0.389, -0.67]
        self.position_8 = [ 1.894, -0.2]
        self.position_9 = [ -1.894, -1.387]
        self.position_10 = [ 1.392, 0.174]
        self.position_11 = [1.309, -0.2]
        self.position_12 = [1.392, 0.174]
        self.position_13 = [1.309, -0.2]
        self.position_14 = [ 1.392, 0.174]
        self.position_15 = [ 1.309, -0.2]
        self.position_16 = [ 1.894, 0.174]

        #Make position
        self._positions.append(self.position_1)
        self._positions.append(self.position_2)
        self._positions.append(self.position_3)
        self._positions.append(self.position_4)
        self._positions.append(self.position_5)
        self._positions.append(self.position_6)
        self._positions.append(self.position_7)
        self._positions.append(self.position_8)
        self._positions.append(self.position_9)
        self._positions.append(self.position_10)
        self._positions_AR.append(self.position_11)
        self._positions_AR.append(self.position_12)
        self._positions_AR.append(self.position_13)
        self._positions_AR.append(self.position_14)
        self._positions_AR.append(self.position_15)
        self._positions_AR.append(self.position_16)

        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.stiffness_ON()
        for position in self._positions:
            self.motion.angleInterpolationWithSpeed(self.joints_list, position, self.test_speed)

        for positionAR in self._positions_AR:
            self.motion.angleInterpolationWithSpeed(self.joints_list, positionAR, self.test_speed_AR)

        self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Speed" inherits_from_parent="0" content_type="2" value="0.5" default_value="0" min="0" max="1" tooltip="" id="5" /><Parameter name="Pause" inherits_from_parent="0" content_type="2" value="0" default_value="0" min="0" max="10" tooltip="" id="6" /><Parameter name="Speed_AR" inherits_from_parent="0" content_type="2" value="0.2" default_value="0" min="0" max="1" tooltip="" id="7" /></Box><Link inputowner="4" indexofinput="5" outputowner="2" indexofoutput="6" /><Link inputowner="4" indexofinput="7" outputowner="2" indexofoutput="8" /><Link inputowner="4" indexofinput="9" outputowner="2" indexofoutput="10" /><Link inputowner="4" indexofinput="11" outputowner="2" indexofoutput="12" /><Link inputowner="4" indexofinput="13" outputowner="2" indexofoutput="14" /><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="0" indexofinput="4" outputowner="4" indexofoutput="14" /><Link inputowner="3" indexofinput="2" outputowner="2" indexofoutput="5" /><Link inputowner="6" indexofinput="2" outputowner="2" indexofoutput="7" /><Link inputowner="4" indexofinput="4" outputowner="3" indexofoutput="4" /><Link inputowner="4" indexofinput="6" outputowner="6" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Link inputowner="7" indexofinput="2" outputowner="4" indexofoutput="5" /><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="1" /><Link inputowner="4" indexofinput="2" outputowner="1" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="7" indexofoutput="4" /><Link inputowner="4" indexofinput="2" outputowner="2" indexofoutput="4" /><Link inputowner="3" indexofinput="2" outputowner="4" indexofoutput="6" /><Link inputowner="2" indexofinput="2" outputowner="3" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer><BehaviorLayer name="Log"><BehaviorKeyframe name="Log" index="1"><Diagram scale="84.0896"><Box name="Long Logger" id="9" localization="8" tooltip="Joint Logger" x="633" y="26"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[import naoqi
import csv
import datetime

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)
        pass

    def onLoad(self):
        self.fr_csv_style = self.getParameter("fr_csv_style")
        i=0

        # Recup parameter
        self.root_path = self.memory_proxy.getData('testbench/config/log/long/path')
        self.file_root_name = self.memory_proxy.getData('testbench/config/log/long/filename')
        self.file_max_lenght = self.memory_proxy.getData('testbench/config/log/long/Buffer')

        # Generate the list of key
        #Root
        self.root_key = "Device/SubDeviceList"

        #Joint List Do not temper with the order
        self.joint_list = self.memory_proxy.getData('testbench/config/list/joint_list')

        self.values_list=["Temperature/Sensor/Value","ElectricCurrent/Sensor/Value","Position/Actuator/Value","Position/Sensor/Value","Hardness/Actuator/Value"]

        # Key List
        self.key_list = []
        # Head temperature
        self.key_list.append("Device/SubDeviceList/Head/Temperature/Sensor/Value")

        self.last_values_list = []

        # Generate and add all the joints key

        for joint in self.joint_list:
            for value in self.values_list:
                key = self.root_key + "/" + joint + "/" + value
                self.key_list.append(key)
                self.last_values_list.append(0)

        # Create the log file
        self.create_new_log_file()
        date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        line_to_write = date_log

        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self):
        try:
            i = self.memory_proxy.getData("log_value")
        except:
            print "key not found"
            i=0

        # Set and start logger
        self.update_values()

        self.update_log_file()
        i=i+1
        self.memory_proxy.insertData("log_value",i)
        if i>=self.file_max_lenght:
            i=0
            self.memory_proxy.insertData("log_value",i)
            self.create_new_log_file()

        self.onStopped()

        pass

    def onInput_onStop(self):
        self.onStopped() #~ activate output of the box
        self.onUnload() #~ it is recommanded to call onUnload of this box in a onStop method, as the code written in onUnload is used to stop the box as well
        pass


    # --- [ Update values ] -----------------------------------------------------------------------------------------------------------------------------------------

    def update_values(self):

        self.last_values_list = self.memory_proxy.getListData(self.key_list)

        for i in range(0, len(self.last_values_list)):
            if self.last_values_list[i] == None: self.last_values_list[i] = 0

    # --- [ update log file ] ---------------------------------------------------------------------------------------------------------------------------------------------------

    def update_log_file(self):

        # Generate log line
        date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        line_to_write = date_log

        if self.fr_csv_style == True:
            separator = ";"
        else:
            separator = ","

        for value in self.last_values_list:

            if self.fr_csv_style == True:
                value = str(value).replace(".",",")

            line_to_write = line_to_write + separator + str(value)

        with open(self.log_file_path,"a") as f:
            line_to_write = line_to_write + "\n"
            f.write(line_to_write)

        pass

    # --- [ Create a new log file ] ---------------------------------------------------------------------------------------------------------------------------------------------------

    def create_new_log_file(self):

        # If the folder does not exist create it
        if not os.path.exists(self.root_path):
            os.mkdir(self.root_path)

         #~ puts code for box initialization here
        date_log = datetime.datetime.now().strftime("%Y-%m-%d_%Hh%Mm")

        self.log_file_name = date_log + "_" + self.file_root_name +".csv"
        self.log_file_path = os.path.join(self.root_path, self.log_file_name)

        if self.fr_csv_style == True:
            separator = ";"
        else:
            separator = ","

        header = "Date,Head"
        for joint in self.joint_list:
            for value in self.values_list:
                header = header + separator + joint + "/" + value

        with open(self.log_file_path,"a") as f:
            f.write(header+"\n")
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="fr_csv_style" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="if enable log are done using ; to separate values and , for float values" id="5" /></Box><Box name="Carac" id="13" localization="8" tooltip="Enter tooltip here" x="468" y="394"><bitmap>media/images/box/shortcut.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="Hours_onStart" type="0" type_size="1" nature="2" inner="0" tooltip="This input has been automatically generated&#x0A;by converting several boxes into a single box." id="2" /><Input name="user_input" type="1" type_size="1" nature="1" inner="0" tooltip="" id="3" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Short Logger" id="1" localization="8" tooltip="Joint Logger" x="651" y="109"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[import naoqi
import csv
import datetime
import os

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = naoqi.ALProxy("ALMemory","127.0.0.1",9559)
        self.launcher = naoqi.ALProxy("ALLauncher","127.0.0.1",9559)
        pass

    def onLoad(self):

        # Recup parameter
        self.root_path = self.mem.getData('testbench/config/log/carac/path')
        self.root_filename = self.mem.getData('testbench/config/log/carac/filename')
        self.file_max_lengh = self.mem.getData('testbench/config/log/carac/Buffer')
        # Create ALMemory Proxy
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self):

        # Set and start logger
        self.setLogger()
        self.startLogger()
        pass

    def onInput_onStop(self):
        # stop the logger and retrieve data

        self.stopLogger()

        self.onStopped() #~ activate output of the box
        self.onUnload() #~ it is recommanded to call onUnload of this box in a onStop method, as the code written in onUnload is used to stop the box as well
        pass



    # ---- [ LOGGER ] -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    # SET DATA LOGGER
    def setLogger(self):

        self.logger.debug("Configuring the data logger...")

        # initializing the logger module  Start --->
        if not self.launcher.isModulePresent('ALSensorLog'):
            self.logger.debug( "ALSensorLog not running on your robot, trying to launch it with ALLauncher")
            self.launcher.launchLocal("sensorlog")

        self.ALSensorLog = ALProxy("ALSensorLog","127.0.0.1",9559)

        self.logPeriod = self.mem.getData('testbench/config/log/carac/sampling')

        self.ALSensorLog.setLogPeriod(self.logPeriod)
        self.ALSensorLog.setMaxBufferDepth(1000000)
        # ---> End


        # Get all data xml key
        # Do not tamper with the order to keep the compatibility with excel tools!

        zero_key = "Device/SubDeviceList/HeadPitch/Position/Sensor/jointZeroPosition"

        joint_list = self.mem.getData('testbench/config/list/joint_list')

        value_list=["Temperature/Sensor/Value","ElectricCurrent/Sensor/Value","Position/Actuator/Value","Position/Sensor/Value","Hardness/Actuator/Value"]

        key_list = []

        # Head temperature
        key_list.append("Device/SubDeviceList/Head/Temperature/Sensor/Value")

        # Joints Information

        root_key = "Device/SubDeviceList"

        for joint in joint_list:
            for value in value_list:
                key = root_key + "/" + joint + "/" + value
                key_list.append(key)

        # Retrieve all the ALMemory Key to log
        nickname_list = []

        # gen nickname
        for key in key_list:

            # Generate nickname by cleaning the key name
            nickname = key.replace("Device/SubDeviceList/","")
            nickname = nickname.replace("Value","")

            # append to nickname list
            nickname_list.append(nickname)

        # set the logger with the key to log and the corresponding nickame
        self.ALSensorLog.setSensorKeys(key_list)
        self.ALSensorLog.setNickNames(nickname_list)
        pass

    # START DATA LOGGING
    def startLogger(self):
        self.ALSensorLog.startSensorLog()
        pass

     # STOP DATA LOGGING
    def stopLogger(self):

        # Stop Sensor log
        self.ALSensorLog.stopSensorLog()

        # Retrieve the log
        log = self.ALSensorLog.getLog()

        log_final = log.replace(chr(9),"")

        time.sleep(1)

        date_log = datetime.datetime.now().strftime("%Y-%m-%d_%Hh%Mm")

        # If the folder does not exist create it
        if not os.path.exists(self.root_path):
            os.mkdir(self.root_path)

        log_file_name = date_log + "_" + self.root_filename + ".csv"
        log_file_path = os.path.join( self.root_path, log_file_name)

        # Write file
        with open(log_file_path, "w") as file_handler:
            file_handler.write(log_final)

        self.logger.debug("Log file written...")

        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="TestBench_Type" inherits_from_parent="1" content_type="3" value="Knee" default_value="Head" custom_choice="0" tooltip="" id="5"><Choice value="CSAM" /><Choice value="T14" /><Choice value="Hand" /><Choice value="Hip" /><Choice value="Knee" /><Choice value="Elastomer" /><Choice value="Arm" /><Choice value="Head" /></Parameter></Box><Box name="Check Carac" id="6" localization="8" tooltip="Enter tooltip here" x="449" y="52"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[import time
class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = naoqi.ALProxy("ALMemory")
        self.load = False
        pass


    def onLoad(self):
        if not self.load:
            self.load = True
            #put initialization code here
            #check warning key
            joint_list = self.mem.getData('testbench/config/list/joint_list')
            prefix_delta = 'testbench/security/delta'

            self.list_warn_delta = ["/".join([prefix_delta,joint]) for joint in joint_list]

            #Memory Key of move (True: in move, Flase: stoped)
            self.move_key1 = 'testbench/movement1/inCycle'
            self.move_key2 = 'testbench/movement2/inCycle'

            self.move_to_stop = 'testbench/movement1/activity'
            self.move_to_start = 'testbench/movement2/activity'
            self.short_key = 'testbench/config/log/short/running'

            #counter of move
            self.max_cycle = self.mem.getData('testbench/config/log/carac/cycle')
            self.counter = 1

            #status key for logger
            self.carac_log_key = 'testbench/config/log/carac/running'
            self.mem.insertData(self.carac_log_key, False)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):

        #wait til short is running
        while self.mem.getData(self.short_key):
            time.sleep(5)
        if not self.mem.getData(self.carac_log_key):
            self.activation_move2(True)
            #indicate to user that carac logger is running
            self.mem.insertData(self.carac_log_key,True)
            #call logger
            self.set_logger()
            #indicate to user that carac logger is stopped
            self.mem.insertData(self.carac_log_key,False)
            self.activation_move2(False)
        self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped

    def set_logger(self):
        #wait the end of the current move
        while self.mem.getData(self.move_key1)or self.mem.getData(self.move_key2):
            time.sleep(0.25)
        #start logger carac
        self.start_logger()
        while self.counter <= self.max_cycle:
            #wait start of move
            while not self.mem.getData(self.move_key2):
                time.sleep(0.25)
            #wait end of move
            while self.mem.getData(self.move_key2):
                time.sleep(0.25)
            self.counter += 1
        #stop logg
        self.stop_logger()
        self.counter = 1

    def onInput_user_input(self):

        if not self.mem.getData(self.carac_log_key):
            self.activation_move2(True)
            #indicate to user that carac logger is running
            self.mem.insertData(self.carac_log_key,True)
            #call logger
            self.set_logger()
            #indicate to user that carac logger is stopped
            self.mem.insertData(self.carac_log_key,False)
            self.activation_move2(False)
        pass

    def activation_move2(self, bool):
        if bool:
            self.mem.insertData(self.move_to_start, bool)
            self.mem.insertData(self.move_to_stop, not bool)
        else:
            self.mem.insertData(self.move_to_stop, not bool)
            self.mem.insertData(self.move_to_start, bool)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Input name="user_input" type="1" type_size="1" nature="1" inner="0" tooltip="" id="4" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="5" /><Output name="start_logger" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /><Output name="stop_logger" type="1" type_size="1" nature="2" inner="0" tooltip="" id="7" /></Box><Box name="Wait" id="7" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="127" y="116"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )
        self.mem = ALProxy('ALMemory')

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        #load parameters of short log count

        self.startTimer( self.mem.getData('testbench/config/log/carac/frequency') )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="5" /></Box><Box name="Wait" id="8" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="133" y="207"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="0.5" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Link inputowner="1" indexofinput="2" outputowner="6" indexofoutput="6" /><Link inputowner="1" indexofinput="3" outputowner="6" indexofoutput="7" /><Link inputowner="6" indexofinput="2" outputowner="7" indexofoutput="4" /><Link inputowner="7" indexofinput="2" outputowner="8" indexofoutput="4" /><Link inputowner="8" indexofinput="2" outputowner="7" indexofoutput="4" /><Link inputowner="7" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="6" indexofinput="4" outputowner="0" indexofoutput="3" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Check Loggeur" id="2" localization="8" tooltip="Enter tooltip here" x="147" y="118"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

        #Recup activation value
    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        self.LongActivation = self.memory_proxy.getData('testbench/config/log/long/activation')
        self.ShortActivation = self.memory_proxy.getData('testbench/config/log/short/activation')
        self.CaracActivation = self.memory_proxy.getData('testbench/config/log/carac/activation')

        if self.LongActivation == True:
            self.LongLog()

        if self.ShortActivation == True:
            self.ShortLog()

        if self.CaracActivation == True:
            self.CaracLog()
        #self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="LongLog" type="1" type_size="1" nature="2" inner="0" tooltip="" id="5" /><Output name="ShortLog" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /><Output name="CaracLog" type="1" type_size="1" nature="2" inner="0" tooltip="" id="7" /></Box><Box name="Short Logger" id="1" localization="8" tooltip="Joint Logger" x="940" y="242"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[import naoqi
import csv
import datetime
import os

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = naoqi.ALProxy("ALMemory","127.0.0.1",9559)
        self.launcher = naoqi.ALProxy("ALLauncher","127.0.0.1",9559)
        pass

    def onLoad(self):

        # Recup parameter
        self.root_path = self.mem.getData('testbench/config/log/short/path')
        self.root_filename = self.mem.getData('testbench/config/log/short/filename')
        self.file_max_lengh = self.mem.getData('testbench/config/log/short/Buffer')
        # Create ALMemory Proxy
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self):

        # Set and start logger
        self.setLogger()
        self.startLogger()
        pass

    def onInput_onStop(self):
        # stop the logger and retrieve data

        self.stopLogger()

        self.onStopped() #~ activate output of the box
        self.onUnload() #~ it is recommanded to call onUnload of this box in a onStop method, as the code written in onUnload is used to stop the box as well
        pass



    # ---- [ LOGGER ] -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    # SET DATA LOGGER
    def setLogger(self):

        self.logger.debug("Configuring the data logger...")

        # initializing the logger module  Start --->
        if not self.launcher.isModulePresent('ALSensorLog'):
            self.logger.debug( "ALSensorLog not running on your robot, trying to launch it with ALLauncher")
            self.launcher.launchLocal("sensorlog")

        self.ALSensorLog = ALProxy("ALSensorLog","127.0.0.1",9559)

        self.logPeriod = self.mem.getData('testbench/config/log/short/sampling')

        self.ALSensorLog.setLogPeriod(self.logPeriod)
        self.ALSensorLog.setMaxBufferDepth(1000000)
        # ---> End


        # Get all data xml key
        # Do not tamper with the order to keep the compatibility with excel tools!

        zero_key = "Device/SubDeviceList/HeadPitch/Position/Sensor/jointZeroPosition"

        joint_list = self.mem.getData('testbench/config/list/joint_list')

        value_list=["Temperature/Sensor/Value","ElectricCurrent/Sensor/Value","Position/Actuator/Value","Position/Sensor/Value","Hardness/Actuator/Value"]

        key_list = []

        # Head temperature
        key_list.append("Device/SubDeviceList/Head/Temperature/Sensor/Value")

        # Joints Information

        root_key = "Device/SubDeviceList"

        for joint in joint_list:
            for value in value_list:
                key = root_key + "/" + joint + "/" + value
                key_list.append(key)

        # Retrieve all the ALMemory Key to log
        nickname_list = []

        # gen nickname
        for key in key_list:

            # Generate nickname by cleaning the key name
            nickname = key.replace("Device/SubDeviceList/","")
            nickname = nickname.replace("Value","")

            # append to nickname list
            nickname_list.append(nickname)

        # set the logger with the key to log and the corresponding nickame
        self.ALSensorLog.setSensorKeys(key_list)
        self.ALSensorLog.setNickNames(nickname_list)
        pass

    # START DATA LOGGING
    def startLogger(self):
        self.ALSensorLog.startSensorLog()
        pass

     # STOP DATA LOGGING
    def stopLogger(self):

        # Stop Sensor log
        self.ALSensorLog.stopSensorLog()

        # Retrieve the log
        log = self.ALSensorLog.getLog()

        log_final = log.replace(chr(9),"")

        time.sleep(1)

        date_log = datetime.datetime.now().strftime("%Y-%m-%d_%Hh%Mm")

        # If the folder does not exist create it
        if not os.path.exists(self.root_path):
            os.mkdir(self.root_path)

        log_file_name = date_log + "_" + self.root_filename + ".csv"
        log_file_path = os.path.join( self.root_path, log_file_name)

        # Write file
        with open(log_file_path, "w") as file_handler:
            file_handler.write(log_final)

        self.logger.debug("Log file written...")

        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="TestBench_Type" inherits_from_parent="1" content_type="3" value="Knee" default_value="Head" custom_choice="0" tooltip="" id="5"><Choice value="CSAM" /><Choice value="T14" /><Choice value="Hand" /><Choice value="Hip" /><Choice value="Knee" /><Choice value="Elastomer" /><Choice value="Arm" /><Choice value="Head" /></Parameter></Box><Box name="Wait Short Code" id="5" localization="8" tooltip="This box is empty and should be used to create any box diagram you would like.&#x0A;&#x0A;To edit its diagram, double-click on it." x="152" y="261"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Tactile Head" id="1" localization="8" tooltip="Detect touch on head tactile sensor." x="110" y="76"><bitmap>media/images/box/sensors/tactileHead.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
            self.onStopped() #~ activate output of the box
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Input name="FrontTactilTouched" type="0" type_size="1" nature="4" stm_value_name="FrontTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="4" /><Input name="MiddleTactilTouched" type="0" type_size="1" nature="4" stm_value_name="MiddleTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="5" /><Input name="RearTactilTouched" type="0" type_size="1" nature="4" stm_value_name="RearTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="6" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is stopped." id="7" /><Output name="frontTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The front tactile head sensor was touched." id="8" /><Output name="middleTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The middle tactile head sensor was touched." id="9" /><Output name="rearTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The rear tactile head sensor was touched." id="10" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="If &gt; 0" id="1" localization="8" tooltip="Transmit only if value is &gt; 0." x="260" y="17"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Box name="If &gt; 0" id="2" localization="8" tooltip="Transmit only if value is &gt; 0." x="256" y="119"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Box name="If &gt; 0" id="3" localization="8" tooltip="Transmit only if value is &gt; 0." x="261" y="223"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="4" /><Link inputowner="0" indexofinput="8" outputowner="1" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="5" /><Link inputowner="0" indexofinput="9" outputowner="2" indexofoutput="4" /><Link inputowner="3" indexofinput="2" outputowner="0" indexofoutput="6" /><Link inputowner="0" indexofinput="10" outputowner="3" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline><Resource name="Head-sequence" type="Lock" timeout="0" /></Box><Box name="Diagram" id="2" localization="8" tooltip="This box is empty and should be used to create any box diagram you would like.&#x0A;&#x0A;To edit its diagram, double-click on it." x="294" y="329"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Link inputowner="0" indexofinput="4" outputowner="0" indexofoutput="2" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Tactile Head" id="3" localization="8" tooltip="Detect touch on head tactile sensor." x="460" y="57"><bitmap>media/images/box/sensors/tactileHead.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
            self.onStopped() #~ activate output of the box
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Input name="FrontTactilTouched" type="0" type_size="1" nature="4" stm_value_name="FrontTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="4" /><Input name="MiddleTactilTouched" type="0" type_size="1" nature="4" stm_value_name="MiddleTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="5" /><Input name="RearTactilTouched" type="0" type_size="1" nature="4" stm_value_name="RearTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="6" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is stopped." id="7" /><Output name="frontTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The front tactile head sensor was touched." id="8" /><Output name="middleTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The middle tactile head sensor was touched." id="9" /><Output name="rearTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The rear tactile head sensor was touched." id="10" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="If &gt; 0" id="1" localization="8" tooltip="Transmit only if value is &gt; 0." x="260" y="17"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Box name="If &gt; 0" id="2" localization="8" tooltip="Transmit only if value is &gt; 0." x="256" y="119"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Box name="If &gt; 0" id="3" localization="8" tooltip="Transmit only if value is &gt; 0." x="261" y="223"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="4" /><Link inputowner="0" indexofinput="8" outputowner="1" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="5" /><Link inputowner="0" indexofinput="9" outputowner="2" indexofoutput="4" /><Link inputowner="3" indexofinput="2" outputowner="0" indexofoutput="6" /><Link inputowner="0" indexofinput="10" outputowner="3" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline><Resource name="Head-sequence" type="Lock" timeout="0" /></Box><Box name="Tactile Head" id="4" localization="8" tooltip="Detect touch on head tactile sensor." x="830" y="53"><bitmap>media/images/box/sensors/tactileHead.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.bIsRunning = False

    def onUnload(self):
        self.bIsRunning = False

    def onInput_onStart(self):
        self.bIsRunning = True

    def onInput_onStop(self):
        if( self.bIsRunning ):
            self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
            self.onStopped() #~ activate output of the box
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Input name="FrontTactilTouched" type="0" type_size="1" nature="4" stm_value_name="FrontTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="4" /><Input name="MiddleTactilTouched" type="0" type_size="1" nature="4" stm_value_name="MiddleTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="5" /><Input name="RearTactilTouched" type="0" type_size="1" nature="4" stm_value_name="RearTactilTouched" inner="1" tooltip="Connected to ALMemory. Will be stimulated every time the value subscribed to changes, respecting the refresh period." id="6" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is stopped." id="7" /><Output name="frontTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The front tactile head sensor was touched." id="8" /><Output name="middleTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The middle tactile head sensor was touched." id="9" /><Output name="rearTouched" type="1" type_size="1" nature="2" inner="0" tooltip="The rear tactile head sensor was touched." id="10" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="If &gt; 0" id="1" localization="8" tooltip="Transmit only if value is &gt; 0." x="260" y="17"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Box name="If &gt; 0" id="2" localization="8" tooltip="Transmit only if value is &gt; 0." x="256" y="119"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Box name="If &gt; 0" id="3" localization="8" tooltip="Transmit only if value is &gt; 0." x="261" y="223"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        #~ puts code for box initialization here
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, p):
        if(p > 0):
            self.onStopped() #~ activate output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #~ it is usually a good idea to call onUnload of this box in a onStop method, as the code written in onUnload is used to finish the working of the box as well
        pass]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /></Box><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="4" /><Link inputowner="0" indexofinput="8" outputowner="1" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="5" /><Link inputowner="0" indexofinput="9" outputowner="2" indexofoutput="4" /><Link inputowner="3" indexofinput="2" outputowner="0" indexofoutput="6" /><Link inputowner="0" indexofinput="10" outputowner="3" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline><Resource name="Head-sequence" type="Lock" timeout="0" /></Box><Box name="Wait" id="5" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="288" y="8"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="0.3" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Box name="Wait" id="6" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="670" y="71"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="0.3" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Box name="Wait" id="7" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="662" y="244"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="4" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Box name="Wait" id="8" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="421" y="373"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="0.5" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="2" indexofinput="2" outputowner="1" indexofoutput="10" /><Link inputowner="2" indexofinput="2" outputowner="1" indexofoutput="9" /><Link inputowner="2" indexofinput="2" outputowner="3" indexofoutput="9" /><Link inputowner="2" indexofinput="2" outputowner="3" indexofoutput="8" /><Link inputowner="0" indexofinput="4" outputowner="4" indexofoutput="8" /><Link inputowner="2" indexofinput="2" outputowner="4" indexofoutput="9" /><Link inputowner="2" indexofinput="2" outputowner="4" indexofoutput="10" /><Link inputowner="4" indexofinput="3" outputowner="4" indexofoutput="8" /><Link inputowner="4" indexofinput="3" outputowner="4" indexofoutput="9" /><Link inputowner="4" indexofinput="3" outputowner="4" indexofoutput="10" /><Link inputowner="3" indexofinput="3" outputowner="3" indexofoutput="8" /><Link inputowner="3" indexofinput="3" outputowner="3" indexofoutput="9" /><Link inputowner="3" indexofinput="3" outputowner="3" indexofoutput="10" /><Link inputowner="1" indexofinput="3" outputowner="1" indexofoutput="8" /><Link inputowner="1" indexofinput="3" outputowner="1" indexofoutput="9" /><Link inputowner="1" indexofinput="3" outputowner="1" indexofoutput="10" /><Link inputowner="5" indexofinput="2" outputowner="1" indexofoutput="8" /><Link inputowner="3" indexofinput="2" outputowner="5" indexofoutput="4" /><Link inputowner="6" indexofinput="2" outputowner="3" indexofoutput="10" /><Link inputowner="4" indexofinput="2" outputowner="6" indexofoutput="4" /><Link inputowner="7" indexofinput="2" outputowner="1" indexofoutput="8" /><Link inputowner="7" indexofinput="2" outputowner="3" indexofoutput="10" /><Link inputowner="7" indexofinput="3" outputowner="2" indexofoutput="4" /><Link inputowner="7" indexofinput="3" outputowner="4" indexofoutput="8" /><Link inputowner="4" indexofinput="3" outputowner="7" indexofoutput="4" /><Link inputowner="3" indexofinput="3" outputowner="7" indexofoutput="4" /><Link inputowner="8" indexofinput="2" outputowner="2" indexofoutput="4" /><Link inputowner="1" indexofinput="2" outputowner="8" indexofoutput="4" /><Link inputowner="8" indexofinput="2" outputowner="7" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Wait" id="3" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="156" y="352"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="1" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Box name="Check Cyclage" id="6" localization="8" tooltip="Enter tooltip here" x="713" y="225"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[import time
class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = naoqi.ALProxy("ALMemory")
        self.list_secu_cycle = ['testbench/security/cyclage/cycle1','testbench/security/cyclage/cycle2','testbench/security/cyclage/cycle3',
        'testbench/security/cyclage/cycle4','testbench/security/cyclage/cycle5']
        pass


    def onLoad(self):
        #put initialization code here
        #check warning key
        joint_list = self.mem.getData('testbench/config/list/joint_list')
        prefix_temp = 'testbench/security/temp'
        prefix_delta = 'testbench/security/delta'

        self.list_warn_temp = ["/".join([prefix_temp,joint]) for joint in joint_list]
        self.list_warn_delta = ["/".join([prefix_delta,joint]) for joint in joint_list]

        #Memory Key of move (True: in move, Flase: stoped)
        self.move_key1 = 'testbench/movement1/inCycle'
        self.move_key2 = 'testbench/movement2/inCycle'
        self.carac_key = 'testbench/config/log/carac/running'

        #counter of move
        self.max_cycle = self.mem.getData('testbench/config/log/short/cycle')
        self.counter = 1

        #status key for logger
        self.shot_log_key = 'testbench/config/log/short/running'
        self.mem.insertData(self.shot_log_key, False)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):

        #wait til carac is running
        while self.mem.getData(self.carac_key):
            time.sleep(5)
        if not self.mem.getData(self.shot_log_key) and self.check_cycle_key():
            #indicate to user that short logger is running
            self.mem.insertData(self.shot_log_key,True)
            #call logger
            self.set_logger()
            #indicate to user that short logger is stopped
            self.mem.insertData(self.shot_log_key,False)
        self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped

    def set_logger(self):
        #wait the end of the current move
        while self.mem.getData(self.move_key1) or self.mem.getData(self.move_key2):
            time.sleep(0.25)
        #start logger short
        self.start_logger()
        while self.counter <= self.max_cycle and self.check_cycle_key():
            #wait start of move
            while not self.mem.getData(self.move_key1):
                time.sleep(0.25)
            #wait end of move
            while self.mem.getData(self.move_key1):
                time.sleep(0.25)
            self.counter += 1
        #stop logg
        self.stop_logger()
        self.counter = 1

    def onInput_user_input(self):

        if not self.mem.getData(self.shot_log_key) and self.check_cycle_key():
            #indicate to user that short logger is running
            self.mem.insertData(self.shot_log_key,True)
            #call logger
            self.set_logger()
            #indicate to user that short logger is stopped
            self.mem.insertData(self.shot_log_key,False)
        pass

    def check_cycle_key(self):
        #check if robot is moving
        secu_list = self.mem.getListData(self.list_secu_cycle)
        secu_list = [secu for secu in secu_list if secu]
        if secu_list:
            return True
        return False]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Input name="user_input" type="1" type_size="1" nature="1" inner="0" tooltip="" id="4" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="5" /><Output name="start_logger" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /><Output name="stop_logger" type="1" type_size="1" nature="2" inner="0" tooltip="" id="7" /></Box><Box name="Wait" id="4" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="633" y="125"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )
        self.mem = ALProxy('ALMemory')

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.mem.getData('testbench/config/log/long/sampling') )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="5" /></Box><Box name="Wait" id="7" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="712" y="328"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )
        self.mem = ALProxy('ALMemory')

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        #load parameters of short log count

        self.startTimer( self.mem.getData('testbench/config/log/short/frequency') )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="5" /></Box><Box name="Wait" id="8" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="718" y="419"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.getParameter("Timeout (s)") )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="0.5" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="6" /></Box><Link inputowner="13" indexofinput="2" outputowner="2" indexofoutput="7" /><Link inputowner="9" indexofinput="2" outputowner="2" indexofoutput="5" /><Link inputowner="3" indexofinput="2" outputowner="5" indexofoutput="4" /><Link inputowner="5" indexofinput="2" outputowner="3" indexofoutput="4" /><Link inputowner="1" indexofinput="2" outputowner="6" indexofoutput="6" /><Link inputowner="1" indexofinput="3" outputowner="6" indexofoutput="7" /><Link inputowner="6" indexofinput="4" outputowner="5" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="1" /><Link inputowner="5" indexofinput="2" outputowner="0" indexofoutput="1" /><Link inputowner="4" indexofinput="2" outputowner="9" indexofoutput="4" /><Link inputowner="9" indexofinput="2" outputowner="4" indexofoutput="4" /><Link inputowner="6" indexofinput="2" outputowner="7" indexofoutput="4" /><Link inputowner="7" indexofinput="2" outputowner="2" indexofoutput="6" /><Link inputowner="7" indexofinput="2" outputowner="8" indexofoutput="4" /><Link inputowner="8" indexofinput="2" outputowner="7" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer><BehaviorLayer name="Security"><BehaviorKeyframe name="Security" index="1"><Diagram scale="84.0896"><Box name="Check Security" id="1" localization="8" tooltip="Enter tooltip here" x="109" y="118"><bitmap>media/images/box/box-script.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)
        pass


    def onLoad(self):
        #put initialization code here
        self.TempActivity = self.memory_proxy.getData("testbench/config/security/temp/activation")
        self.DeltaActivity = self.memory_proxy.getData("testbench/config/security/delta/activation")
        self.BootActivity = self.memory_proxy.getData("testbench/config/security/bootloader/activation")
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box

        if self.TempActivity :
            self.Temperature()

        if self.DeltaActivity :
            self.Delta()

        if self.BootActivity :
            self.Bootloader()
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="Temperature" type="1" type_size="1" nature="2" inner="0" tooltip="" id="5" /><Output name="Delta" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /><Output name="Bootloader" type="1" type_size="1" nature="2" inner="0" tooltip="" id="7" /></Box><Box name="Warning Temperature" id="3" localization="8" tooltip="This box is empty and should be used to create any box diagram you would like.&#x0A;&#x0A;To edit its diagram, double-click on it." x="265" y="54"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Check Temperature" id="2" localization="8" tooltip="This box is empty and should be used to create any box script you would like.&#x0A;&#x0A;To edit its script, double-click on it." x="110" y="34"><bitmap>media/images/box/sensors/getTemperature.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        pass

    def onLoad(self):
        #load available join
        self.joint_list = self.mem.getData("testbench/config/list/joint_list")

        #load value of temperature max ad min
        prefix = "testbench/config/security/temp"
        suffix_min = "TMin"
        suffix_max = "TMax"

        self.temp_max = self.mem.getListData(["/".join([prefix,joint,suffix_max]) for joint in self.joint_list])
        self.temp_min = self.mem.getListData(["/".join([prefix,joint,suffix_min]) for joint in self.joint_list])

        #create list of default for each joint
        self.default = [False for joint in self.joint_list]

        #create list of key for each joint
        prefix = "Device/SubDeviceList"
        suffix = "Temperature/Sensor/Value"

        self.joint_key = ["/".join([prefix,joint,suffix]) for joint in self.joint_list]
        #create list secu
        prefix = "testbench/security/temp"

        self.secu_key = ["/".join([prefix,joint]) for joint in self.joint_list]
        map(self.mem.insertData, self.secu_key, self.default)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        temperature_list=  self.mem.getListData(self.joint_key)
        for index, (joint, value, key, default, TMax, TMin) in enumerate(
                zip(self.joint_list, temperature_list, self.secu_key, self.default, self.temp_max, self.temp_min)):
            #hysteresis
            if default and (value <= TMin):
                self.noMoreDefault(joint)
                self.default[index] = False
                self.mem.insertData(key,False)

            elif not(default) and value >= TMax:

                self.inDefault(joint)
                self.default[index] = True
                self.mem.insertData(key,True)

        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="inDefault" type="1" type_size="1" nature="2" inner="0" tooltip="" id="5" /><Output name="noMoreDefault" type="1" type_size="1" nature="2" inner="0" tooltip="" id="6" /></Box><Box name="Event" id="10" localization="8" tooltip="Enter tooltip here" x="470" y="33"><bitmap>media/images/box/interaction/text_read.png</bitmap><script language="4"><content><![CDATA[import socket
import threading
import os
import time
import sys
import pickle

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        self.sys = ALProxy("ALSystem")
        self.host = '10.0.160.106'
        self.port = 51080
        self.flagDefault = False
        self.i = 0
        pass

    def onLoad(self):
        self.path = self.mem.getData('testbench/config/log/event/path')
        self.file_root_name = self.mem.getData('testbench/config/log/event/filename')
        self.create_new_log_file()
        self.type = self.mem.getData('testbench/config/type')
        self.messages_a_envoyer = []
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, message):
        self.update_log(message)
        self.socket(message)
        pass

    def onInput_onStop(self):
        self.onUnload()
        pass

    def create_new_log_file(self):
        if not os.path.exists(self.path):
            os.mkdir(self.path)
         #~ puts code for box initialization here
        date_log = datetime.datetime.now().strftime("%Y-%m-%d_")
        separator = ";"
        self.log_name = date_log + self.file_root_name + ".csv"
        self.log_file = os.path.join(self.path, self.log_name)
        pass

    def update_log(self, message):
        if message != "" and message != None:
            message_to_send = " : ".join([message, self.getParameter('Message')])
        else:
            message_to_send = self.getParameter('Message')
        # Generate log line
        date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        separator = ";"
        line_to_write = date_log + separator + message_to_send

        with open(self.log_file,"a") as f:
            line_to_write = line_to_write + "\n"
            f.write(line_to_write)

        pass
    def socket(self, message):
        self.messages_a_envoyer=[]

        self.connexion = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        while self.i<11:
            try:
                self.connexion.connect((self.host, self.port))
                print "Connexion etablie avec le serveur."
                self.flagDefault = True
            except socket.error:
                print "la connexion à echoue."
                self.flagDefault = False
                pass


            if self.flagDefault == True:
                date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                self.temp_status = self.mem.getData('testbench/security/temp/' + message)

                self.messages_a_envoyer.append(date_log)
                self.messages_a_envoyer.append(self.type)
                self.messages_a_envoyer.append(self.sys.robotName())
                self.messages_a_envoyer.append(message)
                self.messages_a_envoyer.append(self.temp_status)

                self.message_emis = self.messages_a_envoyer
                msg = "temp"
                self.connexion.send(msg)
                self.message_recut = self.connexion.recv(255)
                print self.message_recut

                if self.message_recut == 'Ok pour temp':
                    data = pickle.dumps(self.message_emis)
                    print self.message_emis
                    self.connexion.send(data)
                self.connexion.close()
                self.i=11
            elif self.flagDefault == False:
                self.i = self.i + 1
        self.i = 0]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Parameter name="Message" inherits_from_parent="0" content_type="3" value="Motor hot" default_value="Message to send" custom_choice="0" tooltip="" id="4" /></Box><Box name="Event" id="3" localization="8" tooltip="Enter tooltip here" x="470" y="126"><bitmap>media/images/box/interaction/text_read.png</bitmap><script language="4"><content><![CDATA[import socket
import threading
import os
import time
import sys
import pickle

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        self.sys = ALProxy("ALSystem")
        self.host = '10.0.160.106'
        self.port = 51080
        self.flagDefault = False
        self.i = 0
        pass

    def onLoad(self):
        self.path = self.mem.getData('testbench/config/log/event/path')
        self.file_root_name = self.mem.getData('testbench/config/log/event/filename')
        self.create_new_log_file()
        self.type = self.mem.getData('testbench/config/type')
        self.messages_a_envoyer = []
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, message):
        self.update_log(message)
        self.socket(message)
        pass

    def onInput_onStop(self):
        self.onUnload()
        pass

    def create_new_log_file(self):
        if not os.path.exists(self.path):
            os.mkdir(self.path)
         #~ puts code for box initialization here
        date_log = datetime.datetime.now().strftime("%Y-%m-%d_")
        separator = ";"
        self.log_name = date_log + self.file_root_name + ".csv"
        self.log_file = os.path.join(self.path, self.log_name)
        pass

    def update_log(self, message):
        if message != "" and message != None:
            message_to_send = " : ".join([message, self.getParameter('Message')])
        else:
            message_to_send = self.getParameter('Message')
        # Generate log line
        date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        separator = ";"
        line_to_write = date_log + separator + message_to_send

        with open(self.log_file,"a") as f:
            line_to_write = line_to_write + "\n"
            f.write(line_to_write)

        pass
    def socket(self, message):
        self.messages_a_envoyer=[]

        self.connexion = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        while self.i<11:
            try:
                self.connexion.connect((self.host, self.port))
                print "Connexion etablie avec le serveur."
                self.flagDefault = True
            except socket.error:
                print "la connexion à echoue."
                self.flagDefault = False
                pass


            if self.flagDefault == True:
                date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                self.temp_status = self.mem.getData('testbench/security/temp/' + message)

                self.messages_a_envoyer.append(date_log)
                self.messages_a_envoyer.append(self.type)
                self.messages_a_envoyer.append(self.sys.robotName())
                self.messages_a_envoyer.append(message)
                self.messages_a_envoyer.append(self.temp_status)

                self.message_emis = self.messages_a_envoyer
                msg = "temp"
                self.connexion.send(msg)
                self.message_recut = self.connexion.recv(255)
                print self.message_recut

                if self.message_recut == 'Ok pour temp':
                    data = pickle.dumps(self.message_emis)
                    print self.message_emis
                    self.connexion.send(data)
                self.connexion.close()
                self.i=11
            elif self.flagDefault == False:
                self.i = self.i + 1
        self.i = 0]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Parameter name="Message" inherits_from_parent="0" content_type="3" value="Motor cold" default_value="Message to send" custom_choice="0" tooltip="" id="4" /></Box><Box name="Wait" id="1" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="113" y="132"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )
        self.mem = ALProxy('ALMemory')

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.mem.getData('testbench/config/security/temp/sampling') )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="5" /></Box><Link inputowner="10" indexofinput="2" outputowner="2" indexofoutput="5" /><Link inputowner="3" indexofinput="2" outputowner="2" indexofoutput="6" /><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="1" indexofinput="2" outputowner="2" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="1" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Warning Delta" id="4" localization="8" tooltip="This box is empty and should be used to create any box diagram you would like.&#x0A;&#x0A;To edit its diagram, double-click on it." x="267" y="146"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Check Delta" id="1" localization="8" tooltip="This box is empty and should be used to create any box script you would like.&#x0A;&#x0A;To edit its script, double-click on it." x="82" y="20"><bitmap>media/images/box/movement/stand.png</bitmap><script language="4"><content><![CDATA[import time
class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        pass


    def onLoad(self):
        #put initialization code here
        #create list of usefull joint
        self.joint_list = self.mem.getData('testbench/config/list/joint_list')
        #configuration of permissible delta
        prefix = 'testbench/config/security/delta'
        suffix = 'value'
        delta_key = ['/'.join([prefix,joint,suffix]) for joint in self.joint_list]

        self.delta_list = self.mem.getListData(delta_key)

        #create activator and sensor key
        prefix = "Device/SubDeviceList"
        suffix_sensor = "Position/Sensor/Value"
        suffix_actuator = "Position/Actuator/Value"

        self.actuator_list_key = ["/".join([prefix,joint,suffix_actuator]) for joint in self.joint_list]
        self.sensor_list_key = ["/".join([prefix,joint,suffix_sensor]) for joint in self.joint_list]

        #create counter for each joint
        self.counter_list = [0 for joint in self.joint_list]

        #create default list for each joint
        self.defaut_key = "testbench/security/delta"
        [self.mem.insertData('/'.join([self.defaut_key,joint]),False) for joint in self.joint_list]

        #number max of delta error
        self.nb_max_delta = self.mem.getData('testbench/config/security/delta/stop')
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box

        #load actuator and sensor position
        actuator_sensor_list = [self.mem.getListData([actuator,sensor]) for actuator,sensor in
                zip(self.actuator_list_key,self.sensor_list_key)]

        print(actuator_sensor_list)


        #check error
        for index, (joint, (actuator,sensor), counter, delta) in enumerate(
                zip(self.joint_list, actuator_sensor_list, self.counter_list, self.delta_list)):
            #check delta for each joint
            #check delta only if secu temp is at False
            secu_temp = 'testbench/security/temp'
            if abs((actuator-sensor)) >= delta and not self.mem.getData("/".join([secu_temp,joint])): ###### TEST #####
                self.counter_list[index] = counter + 1
            else:
                self.counter_list[index] = 0
            #generate error
            if self.counter_list[index] >= self.nb_max_delta and not self.mem.getData('/'.join([self.defaut_key,joint])):
                self.mem.insertData('/'.join([self.defaut_key,joint]),True)
                self.inDefault(joint)

        self.onStopped()

        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="inDefault" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" /></Box><Box name="Wait" id="2" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="85" y="111"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )
        self.mem = ALProxy('ALMemory')

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.mem.getData('testbench/config/security/delta/sampling') )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="5" /></Box><Box name="Event" id="3" localization="8" tooltip="Enter tooltip here" x="318" y="93"><bitmap>media/images/box/interaction/text_read.png</bitmap><script language="4"><content><![CDATA[import socket
import threading
import os
import time
import sys
import pickle

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        self.sys = ALProxy("ALSystem")
        self.host = '10.0.160.106'
        self.port = 51080
        self.flagDefault = False
        self.i = 0
        pass

    def onLoad(self):
        self.path = self.mem.getData('testbench/config/log/event/path')
        self.file_root_name = self.mem.getData('testbench/config/log/event/filename')
        self.type = self.mem.getData('testbench/config/type')
        self.create_new_log_file()
        self.type = self.mem.getData('testbench/config/type')
        self.messages_a_envoyer = []
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, message):
        self.update_log(message)
        self.socket(message)
        pass

    def onInput_onStop(self):
        self.onUnload()
        pass

    def create_new_log_file(self):
        if not os.path.exists(self.path):
            os.mkdir(self.path)
         #~ puts code for box initialization here
        date_log = datetime.datetime.now().strftime("%Y-%m-%d_")
        separator = ";"
        self.log_name = date_log + self.file_root_name + ".csv"
        self.log_file = os.path.join(self.path, self.log_name)
        pass

    def update_log(self, message):
        if message != "" and message != None:
            message_to_send = " : ".join([message, self.getParameter('Message')])
        else:
            message_to_send = self.getParameter('Message')
        # Generate log line
        date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        separator = ";"
        line_to_write = date_log + separator + message_to_send

        with open(self.log_file,"a") as f:
            line_to_write = line_to_write + "\n"
            f.write(line_to_write)

        pass
    def socket(self, message):
        self.messages_a_envoyer=[]

        self.connexion = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        while self.i<11:
            try:
                self.connexion.connect((self.host, self.port))
                print "Connexion etablie avec le serveur."
                self.flagDefault = True
            except socket.error:
                print "la connexion à echoue."
                self.flagDefault = False
                pass

            if self.flagDefault == True:
                date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                self.actuator = self.mem.getData('Device/SubDeviceList/' + message + '/Position/Actuator/Value')
                self.delta_status = self.mem.getData('testbench/security/delta/' + message)
                self.sensor = self.mem.getData('Device/SubDeviceList/' + message + '/Position/Sensor/Value')
                self.delta_value = str(self.actuator - self.sensor)

                self.messages_a_envoyer.append(date_log)
                self.messages_a_envoyer.append(self.type)
                self.messages_a_envoyer.append(self.sys.robotName())
                self.messages_a_envoyer.append(message)
                self.messages_a_envoyer.append(self.delta_status)
                self.messages_a_envoyer.append(self.delta_value)

                self.message_emis = self.messages_a_envoyer
                msg = "delta"
                self.connexion.send(msg)
                self.message_recut = self.connexion.recv(255)
                print self.message_recut

                if self.message_recut == 'Ok pour Delta':
                    data = pickle.dumps(self.message_emis)
                    print self.message_emis
                    self.connexion.send(data)
                self.connexion.close()
                self.i=11
            elif self.flagDefault == False:
                self.i = self.i + 1
        self.i = 0]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Parameter name="Message" inherits_from_parent="0" content_type="3" value="Delta Error" default_value="Message to send" custom_choice="0" tooltip="" id="4" /></Box><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="2" indexofinput="2" outputowner="1" indexofoutput="4" /><Link inputowner="1" indexofinput="2" outputowner="2" indexofoutput="4" /><Link inputowner="3" indexofinput="2" outputowner="1" indexofoutput="5" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Warning Booloader" id="5" localization="8" tooltip="Enter tooltip here" x="268" y="256"><bitmap>media/images/box/box-diagram.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="Bootloader_onStart" type="0" type_size="1" nature="2" inner="0" tooltip="This input has been automatically generated&#x0A;by converting several boxes into a single box." id="2" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Bootloader" id="2" localization="8" tooltip="" x="266" y="259"><bitmap>media/images/box/box-python-script.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy("ALMemory")
        self.dicoCard = {
            "LeftArmBoard" : ['LShoulderPitch','LShoulderRoll'],
            "RightArmBoard" : ['RShoulderPitch','RShoulderRoll'],
            "LeftHandBoard" : ['LShoulderPitch','LShoulderRoll', 'LElbowYaw', 'LElbowRoll'],
            "RightHandBoard" : ['RShoulderPitch','RShoulderRoll', 'RElbowYaw', 'RElbowRoll']
            }


    def onLoad(self):

        prefix = "Device/DeviceList"
        suffix = "BootLoaderVersion"
        self.memoryKey = "testbench/security/bootloader"
        self.flagKey = "testbench/security/bootloard/flag"
        self.maxDefault = 60

        self.listCard = self.mem.getData('testbench/config/security/bootloader/cardlist')
        self.listCardHeader = ["/".join([prefix, card, suffix]) for card in self.listCard]

        #creat list of default
        self.defaultCounter = [0 for card in self.listCard]

        #creation of memory key for each card
        for card in self.listCard:
            self.mem.insertData("/".join([self.memoryKey,card]), False)

        #creation of key for each articulation
        for card in self.listCard:
            for articulation in self.dicoCard[card]:
                self.mem.insertData("/".join([self.memoryKey, articulation]), False)
        #creation of memory default flag
        self.mem.insertData(self.flagKey, False)

        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        self.update_boot()
        self.onStopped()
        pass

    def onInput_onStop(self):
        self.onUnload()
        self.onStopped()

     # --- [ update bootloader ] -------------------------------------------------------------------------------------------------------------------------------------------

    def update_boot(self):
        #creat a list of bootloaderVersion
        listBoot = map(self.mem.getData, self.listCardHeader)
        #creat list of boorloader error
        error = [boot for boot in listBoot if not boot]
        #check default
        if error:
            for index, (boot, card) in enumerate(zip(listBoot, self.listCard)):
                if not boot:
                    self.defaultCounter[index] += 1
                    time.sleep(2)
                    if self.defaultCounter >= self.maxDefault:
                        self.defaultOuput("Default on card \"%s\", BootLoader = 0" % card)
                        self.mem.insertData(self.flagKey, True)
                        #creation of articulation default
                        for articulation in self.dicoCard[card]:
                            self.mem.insertData("/".join([self.memoryKey, articulation]), True)
                else:
                    self.defaultCounter[index] = 0]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Output name="defaultOuput" type="0" type_size="1" nature="2" inner="0" tooltip="" id="5" /><Parameter name="TestBench_Type" inherits_from_parent="1" content_type="3" value="CSAM" default_value="Head" custom_choice="0" tooltip="" id="6"><Choice value="CSAM" /><Choice value="T14" /><Choice value="Hand" /><Choice value="Hip" /><Choice value="Knee" /><Choice value="Elastomer" /><Choice value="Arm" /><Choice value="Head" /></Parameter></Box><Box name="Wait" id="7" localization="8" tooltip="Wait a moment before sending a signal on the output. The wait can be stopped any&#x0A;time. You may restart it any time, and it will start again." x="269" y="354"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[import threading

class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )
        self.mem = ALProxy('ALMemory')

    def onLoad(self):
        self.tb = False

    def onUnload(self):
        if( self.tb ):
            self.tb.cancel()
            self.tb = False

    def triggerOutput( self, rPeriod = 1 ):
        self.onUnload() # to clean everything
        self.timerOutput()

    def startTimer( self, rPeriod = 1 ):
        if( self.tb ):
            self.tb.cancel()
        self.tb = threading.Timer( rPeriod, self.triggerOutput, [rPeriod] )
        self.tb.start()

    def onInput_onStart(self):
        self.startTimer( self.mem.getData('testbench/config/security/bootloader/sampling') )

    def onInput_onStop(self):
        bRunning = self.tb
        self.onUnload()
        if( bRunning and self.getParameter("Trigger timerOutput if cancelled")):
            self.timerOutput()]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" /><Output name="timerOutput" type="1" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is ellapsed, or if the box is stopped." id="4" /><Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="5" /></Box><Box name="Event" id="8" localization="8" tooltip="Enter tooltip here" x="471" y="236"><bitmap>media/images/box/interaction/text_read.png</bitmap><script language="4"><content><![CDATA[import socket
import threading
import os
import time
import sys
import pickle

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.mem = ALProxy('ALMemory')
        self.sys = ALProxy("ALSystem")
        self.host = '10.0.160.106'
        self.port = 51080
        self.flagDefault = False
        self.i = 0
        pass

    def onLoad(self):
        self.path = self.mem.getData('testbench/config/log/event/path')
        self.file_root_name = self.mem.getData('testbench/config/log/bootloader/filename')
        self.create_new_log_file()
        self.type = self.mem.getData('testbench/config/type')
        self.messages_a_envoyer = []
        pass

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onStart(self, message):
        self.update_log(message)
        self.socket(message)
        pass

    def onInput_onStop(self):
        self.onUnload()
        pass

    def create_new_log_file(self):
        if not os.path.exists(self.path):
            os.mkdir(self.path)
         #~ puts code for box initialization here
        date_log = datetime.datetime.now().strftime("%Y-%m-%d_")
        separator = ";"
        self.log_name = date_log + self.file_root_name + ".csv"
        self.log_file = os.path.join(self.path, self.log_name)
        pass

    def update_log(self, message):
        if message != "" and message != None:
            message_to_send = " : ".join([message, self.getParameter('Message')])
        else:
            message_to_send = self.getParameter('Message')
        # Generate log line
        date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        separator = ";"
        line_to_write = date_log + separator + message_to_send

        with open(self.log_file,"a") as f:
            line_to_write = line_to_write + "\n"
            f.write(line_to_write)

        pass
    def socket(self, message):
        self.messages_a_envoyer=[]
        self.connexion = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        while self.i<11:
            try:
                self.connexion.connect((self.host, self.port))
                print "Connexion etablie avec le serveur."
                self.flagDefault = True

            except socket.error:
                print "la connexion à echoue."
                self.flagDefault = False
                pass

            if self.flagDefault == True:
                date_log = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                try:
                    self.boot_status = self.mem.getData('testbench/security/bootloader/' + message)
                except:
                    self.boot_status = '0'

                self.messages_a_envoyer.append(date_log)
                self.messages_a_envoyer.append(self.type)
                self.messages_a_envoyer.append(self.sys.robotName())
                self.messages_a_envoyer.append(message)
                self.messages_a_envoyer.append(self.boot_status)

                self.message_emis = self.messages_a_envoyer
                msg = "boot"
                self.connexion.send(msg)
                self.message_recut = self.connexion.recv(255)
                print self.message_recut

                if self.message_recut == 'Ok pour boot':
                    data = pickle.dumps(self.message_emis)
                    print self.message_emis
                    self.connexion.send(data)
                self.connexion.close()
                self.i=11
            elif self.flagDefault == False:
                self.i = self.i + 1
        self.i = 0]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Parameter name="Message" inherits_from_parent="0" content_type="3" value="Left Bootloader Error" default_value="Message to send" custom_choice="0" tooltip="" id="4" /></Box><Link inputowner="8" indexofinput="2" outputowner="2" indexofoutput="5" /><Link inputowner="7" indexofinput="2" outputowner="2" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="7" indexofoutput="4" /><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="2" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Link inputowner="3" indexofinput="2" outputowner="1" indexofoutput="5" /><Link inputowner="4" indexofinput="2" outputowner="1" indexofoutput="6" /><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="1" /><Link inputowner="5" indexofinput="2" outputowner="1" indexofoutput="7" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Parameters Init" id="4" localization="8" tooltip="This box is empty and should be used to create any box diagram you would like.&#x0A;&#x0A;To edit its diagram, double-click on it." x="87" y="36"><bitmap>media/images/box/folder.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)



    def onLoad(self):
        # Log Status Activation
        self.BehaviorVersion = self.getParameter('Behavior Version')
        self.RootPath = self.getParameter('Root Path')
        self.ActivationLongLog = self.getParameter('Enabled Long Log')
        self.ActivationShortLog = self.getParameter('Enabled Short Log')
        self.ActivationCaracLog = self.getParameter('Enabled Carac Log')
        self.ActivationCycleLog = self.getParameter('Enabled Cycle Log')
        self.ActivationConfigLog = self.getParameter('Enabled Config Log')
        # Security Status Activation
        self.ActivationSecurityTemp = self.getParameter('Enabled Temperature Security')
        self.ActivationSecurityDelta = self.getParameter('Enabled Delta Security')
        self.ActivationSecurityBoot = self.getParameter('Enabled Bootloader Security')
        #Target Status Activation
        self.ActivationTarget = self.getParameter('Enabled Target Stop')

        # Insert Data in Almemory
         # Data Activation Log
        self.memory_proxy.insertData("testbench/config/log/long/activation",self.ActivationLongLog)
        self.memory_proxy.insertData("testbench/config/log/short/activation",self.ActivationShortLog)
        self.memory_proxy.insertData("testbench/config/log/carac/activation",self.ActivationCaracLog)
        self.memory_proxy.insertData("testbench/config/log/cycle/activation",self.ActivationCycleLog)
        self.memory_proxy.insertData("testbench/config/log/config/activation",self.ActivationConfigLog)
         # Data Activation Security
        self.memory_proxy.insertData("testbench/config/security/temp/activation",self.ActivationSecurityTemp)
        self.memory_proxy.insertData("testbench/config/security/delta/activation",self.ActivationSecurityDelta)
        self.memory_proxy.insertData("testbench/config/security/bootloader/activation",self.ActivationSecurityBoot)
         # Data Activation Target Stop
        self.memory_proxy.insertData("testbench/config/target/activation",self.ActivationTarget)

        self.memory_proxy.insertData("testbench/config/log/short/running", False)
        self.memory_proxy.insertData("testbench/config/log/carac/running", False)

        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Behavior Version" inherits_from_parent="0" content_type="3" value="Generic" default_value="" custom_choice="0" tooltip="" id="5" /><Parameter name="Root Path" inherits_from_parent="0" content_type="3" value="/home/nao" default_value="/home/nao" custom_choice="0" tooltip="" id="6" /><Parameter name="Enabled Long Log" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="7" /><Parameter name="Enabled Short Log" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="8" /><Parameter name="Enabled Carac Log" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="9" /><Parameter name="Enabled Cycle Log" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="10" /><Parameter name="Enabled Config Log" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="11" /><Parameter name="Enabled Temperature Security" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="12" /><Parameter name="Enabled Delta Security" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="13" /><Parameter name="Enabled Bootloader Security" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="14" /><Parameter name="Enabled Target Stop" inherits_from_parent="0" content_type="0" value="1" default_value="1" tooltip="" id="15" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram scale="84.0896"><Box name="Long Log" id="2" localization="8" tooltip="Enter tooltip here" x="348" y="15"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

    def onLoad(self):
        # Get Filename Logger
        self.SamplingRate = self.getParameter('Sampling Rate')
        self.Frequency = self.getParameter('Frequency')
        self.Buffer = self.getParameter('Buffer')
        self.Frequency_choice = self.getParameter('Unit Fr')
        self.Sampling_choice = self.getParameter('Unit Sr')


        #Frequency
        if self.Frequency_choice=='minutes':
            self.frequency_value = self.Frequency * 60
        elif self.Frequency_choice == 'hours':
            self.frequency_value = self.Frequency * 3600
        elif self.Frequency_choice == 'Days':
            self.frequency_value = self.Frequency * 86400

        #Sampling
        if self.Sampling_choice == 'Millisecondes':
            self.sampling_value = self.SamplingRate * 0.001
        elif self.Sampling_choice == 'Minutes':
            self.sampling_value = self.SamplingRate *60
        elif self.Sampling_choice == 'Hours':
            self.sampling_value = self.SamplingRate * 3600
        else:
            self.sampling_value = self.SamplingRate
        pass

        self.memory_proxy.insertData("testbench/config/log/long/frequency",self.frequency_value)
        self.memory_proxy.insertData("testbench/config/log/long/sampling",self.sampling_value)
        self.memory_proxy.insertData("testbench/config/log/long/Buffer",self.Buffer)

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        # Insert Data in Almemory
        #Data Frequency
        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Sampling Rate" inherits_from_parent="0" content_type="1" value="2" default_value="2" min="0" max="100" tooltip="" id="5" /><Parameter name="Unit Sr" inherits_from_parent="0" content_type="3" value="Seconds" default_value="Hours" custom_choice="0" tooltip="" id="6"><Choice value="Milliseconds" /><Choice value="Seconds" /><Choice value="Minutes" /><Choice value="Hours" /></Parameter><Parameter name="Frequency" inherits_from_parent="0" content_type="1" value="0" default_value="0" min="0" max="100" tooltip="" id="7" /><Parameter name="Unit Fr" inherits_from_parent="0" content_type="3" value="hours" default_value="Days" custom_choice="0" tooltip="" id="8"><Choice value="minutes" /><Choice value="hours" /><Choice value="Days" /></Parameter><Parameter name="Buffer" inherits_from_parent="0" content_type="1" value="10000" default_value="10000" min="1" max="100000" tooltip="" id="9" /></Box><Box name="Filename Log" id="1" localization="8" tooltip="Enter tooltip here" x="350" y="393"><bitmap>media/images/box/folder.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)


    def onLoad(self):
        # Get Filename Logger
        self.PathLog = self.getParameter('Root Path')
        self.NameLongLog = self.getParameter('Filename Long')
        self.NameShortLog = self.getParameter('Filename Short')
        self.NameCaracLog = self.getParameter('Filename Carac')
        self.NameEventLog = self.getParameter('Filename Event')
        self.NameConfigLog = self.getParameter('Filename Config')
        self.NameCycleLog = self.getParameter('Filename Cycle')
        self.NameBootLog = self.getParameter('Filename Bootloader')
        pass

        # Data Log Name
        self.memory_proxy.insertData("testbench/config/log/long/filename",self.NameLongLog)
        self.memory_proxy.insertData("testbench/config/log/short/filename",self.NameShortLog)
        self.memory_proxy.insertData("testbench/config/log/carac/filename",self.NameCaracLog)
        self.memory_proxy.insertData("testbench/config/log/event/filename",self.NameEventLog)
        self.memory_proxy.insertData("testbench/config/log/config/filename",self.NameConfigLog)
        self.memory_proxy.insertData("testbench/config/log/cycle/filename",self.NameCycleLog)
        self.memory_proxy.insertData("testbench/config/log/bootloader/filename",self.NameBootLog)

         # Log Path
        self.PathLog = self.PathLog + "/" + "Log"
        self.PathLongLog = self.PathLog + "/" + "Long"
        self.PathShortLog = self.PathLog + "/" + "Short"
        self.PathCaracLog = self.PathLog + "/" + "Carac"
        self.PathEventLog = self.PathLog + "/" + "Event"
        self.PathConfigLog = self.PathLog + "/" + "Config"
        self.PathCycleLog = self.PathLog + "/" + "Cycle"

         # Data Log Path
        self.memory_proxy.insertData("testbench/config/log/path",self.PathLog)
        self.memory_proxy.insertData("testbench/config/log/long/path",self.PathLongLog)
        self.memory_proxy.insertData("testbench/config/log/short/path",self.PathShortLog)
        self.memory_proxy.insertData("testbench/config/log/carac/path",self.PathCaracLog)
        self.memory_proxy.insertData("testbench/config/log/event/path",self.PathEventLog)
        self.memory_proxy.insertData("testbench/config/log/config/path",self.PathConfigLog)
        self.memory_proxy.insertData("testbench/config/log/cycle/path",self.PathCycleLog)


    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        # Insert Data in Almemory
        if not os.path.exists(self.PathLog):
            os.mkdir(self.PathLog)
        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Filename Long" inherits_from_parent="0" content_type="3" value="joint_logger_long" default_value="" custom_choice="0" tooltip="" id="5" /><Parameter name="Filename Short" inherits_from_parent="0" content_type="3" value="joint_logger_short" default_value="" custom_choice="0" tooltip="" id="6" /><Parameter name="Filename Carac" inherits_from_parent="0" content_type="3" value="joint_logger_carac" default_value="" custom_choice="0" tooltip="" id="7" /><Parameter name="Filename Event" inherits_from_parent="0" content_type="3" value="event_logger" default_value="" custom_choice="0" tooltip="" id="8" /><Parameter name="Filename Config" inherits_from_parent="0" content_type="3" value="config_logger" default_value="" custom_choice="0" tooltip="" id="9" /><Parameter name="Root Path" inherits_from_parent="1" content_type="3" value="/home/nao" default_value="" custom_choice="0" tooltip="" id="10" /><Parameter name="Filename Cycle" inherits_from_parent="0" content_type="3" value="cycle_Log" default_value="cycle_Log" custom_choice="0" tooltip="" id="11" /><Parameter name="Filename Bootloader" inherits_from_parent="0" content_type="3" value="warning_bootloader" default_value="" custom_choice="0" tooltip="" id="12" /></Box><Box name="Security" id="4" localization="8" tooltip="Enter tooltip here" x="350" y="297"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

    def onLoad(self):
         # Get Config Security
        self.SamplingRateTemp = self.getParameter('Sampling Rate Temperature')
        self.SamplingRateDelta = self.getParameter('Sampling Rate Delta')
        self.DeltaStop = self.getParameter('Num Delta Stop')

        self.memory_proxy.insertData("testbench/config/security/temp/sampling",self.SamplingRateTemp)
        self.memory_proxy.insertData("testbench/config/security/delta/sampling",self.SamplingRateDelta)
        self.memory_proxy.insertData("testbench/config/security/delta/stop",self.DeltaStop)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #Insert Data in AlMemory

        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Sampling Rate Temperature" inherits_from_parent="0" content_type="1" value="5" default_value="5" min="1" max="100" tooltip="" id="5" /><Parameter name="Sampling Rate Delta" inherits_from_parent="0" content_type="1" value="1" default_value="1" min="1" max="100" tooltip="" id="6" /><Parameter name="Num Delta Stop" inherits_from_parent="0" content_type="1" value="10" default_value="3" min="1" max="100" tooltip="" id="7" /></Box><Box name="Wait for Signal" id="10" localization="8" tooltip="Enter tooltip here" x="847" y="182"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="Wait For Signals_signal1" type="0" type_size="1" nature="2" inner="0" tooltip="This input has been automatically generated&#x0A;by converting several boxes into a single box." id="2" /><Input name="Wait For Signals_signal2" type="0" type_size="1" nature="2" inner="0" tooltip="This input has been automatically generated&#x0A;by converting several boxes into a single box." id="3" /><Input name="Wait For Signals_signal1_2" type="0" type_size="1" nature="2" inner="0" tooltip="This input has been automatically generated&#x0A;by converting several boxes into a single box." id="4" /><Input name="Wait For Signals_signal2_2" type="0" type_size="1" nature="2" inner="0" tooltip="This input has been automatically generated&#x0A;by converting several boxes into a single box." id="5" /><Input name="Wait For Signals_signal2_3" type="0" type_size="1" nature="2" inner="0" tooltip="This input has been automatically generated&#x0A;by converting several boxes into a single box." id="6" /><Input name="Wait For Signals_signal2_4" type="0" type_size="1" nature="2" inner="0" tooltip="" id="7" /><Input name="Wait for signals_3" type="0" type_size="1" nature="1" inner="0" tooltip="" id="8" /><Output name="WaitForSignals_signalsReceived" type="0" type_size="1" nature="2" inner="0" tooltip="This output has been automatically generated&#x0A;by converting several boxes into a single box." id="9" /><Timeline enable="0"><BehaviorLayer name="behavior_layer1"><BehaviorKeyframe name="keyframe1" index="1"><Diagram><Box name="Wait For Signals" id="5" localization="8" tooltip="Wait for both inputs to be stimulated before stimulating its output." x="392" y="12"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.ok = [False]*2

    def onUnload(self):
        #puts code for box cleanup here
        ""

    def onStart(self, nInput):
        self.ok[nInput-1] = True
        bOutput = True
        for bOk in self.ok:
            bOutput = bOutput and bOk
        if( bOutput ):
            self.ok = [False]*2
            self.signalsReceived()

    def onInput_signal1(self):
        self.onStart(1)

    def onInput_signal2(self):
        self.onStart(2)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" /><Input name="signal1" type="1" type_size="1" nature="1" inner="0" tooltip="First signal to wait." id="2" /><Input name="signal2" type="1" type_size="1" nature="1" inner="0" tooltip="Second signal to wait." id="3" /><Output name="signalsReceived" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when both inputs have been stimulated." id="4" /></Box><Box name="Wait For Signals" id="6" localization="8" tooltip="Wait for both inputs to be stimulated before stimulating its output." x="398" y="119"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.ok = [False]*2

    def onUnload(self):
        #puts code for box cleanup here
        ""

    def onStart(self, nInput):
        self.ok[nInput-1] = True
        bOutput = True
        for bOk in self.ok:
            bOutput = bOutput and bOk
        if( bOutput ):
            self.ok = [False]*2
            self.signalsReceived()

    def onInput_signal1(self):
        self.onStart(1)

    def onInput_signal2(self):
        self.onStart(2)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" /><Input name="signal1" type="1" type_size="1" nature="1" inner="0" tooltip="First signal to wait." id="2" /><Input name="signal2" type="1" type_size="1" nature="1" inner="0" tooltip="Second signal to wait." id="3" /><Output name="signalsReceived" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when both inputs have been stimulated." id="4" /></Box><Box name="Wait For Signals" id="8" localization="8" tooltip="Wait for both inputs to be stimulated before stimulating its output." x="639" y="134"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.ok = [False]*2

    def onUnload(self):
        #puts code for box cleanup here
        ""

    def onStart(self, nInput):
        self.ok[nInput-1] = True
        bOutput = True
        for bOk in self.ok:
            bOutput = bOutput and bOk
        if( bOutput ):
            self.ok = [False]*2
            self.signalsReceived()

    def onInput_signal1(self):
        self.onStart(1)

    def onInput_signal2(self):
        self.onStart(2)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" /><Input name="signal1" type="1" type_size="1" nature="1" inner="0" tooltip="First signal to wait." id="2" /><Input name="signal2" type="1" type_size="1" nature="1" inner="0" tooltip="Second signal to wait." id="3" /><Output name="signalsReceived" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when both inputs have been stimulated." id="4" /></Box><Box name="Wait For Signals" id="9" localization="8" tooltip="Wait for both inputs to be stimulated before stimulating its output." x="848" y="212"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.ok = [False]*2

    def onUnload(self):
        #puts code for box cleanup here
        ""

    def onStart(self, nInput):
        self.ok[nInput-1] = True
        bOutput = True
        for bOk in self.ok:
            bOutput = bOutput and bOk
        if( bOutput ):
            self.ok = [False]*2
            self.signalsReceived()

    def onInput_signal1(self):
        self.onStart(1)

    def onInput_signal2(self):
        self.onStart(2)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" /><Input name="signal1" type="1" type_size="1" nature="1" inner="0" tooltip="First signal to wait." id="2" /><Input name="signal2" type="1" type_size="1" nature="1" inner="0" tooltip="Second signal to wait." id="3" /><Output name="signalsReceived" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when both inputs have been stimulated." id="4" /></Box><Box name="Wait For Signals (1)" id="1" localization="8" tooltip="Wait for both inputs to be stimulated before stimulating its output." x="403" y="232"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.ok = [False]*2

    def onUnload(self):
        #puts code for box cleanup here
        ""

    def onStart(self, nInput):
        self.ok[nInput-1] = True
        bOutput = True
        for bOk in self.ok:
            bOutput = bOutput and bOk
        if( bOutput ):
            self.ok = [False]*2
            self.signalsReceived()

    def onInput_signal1(self):
        self.onStart(1)

    def onInput_signal2(self):
        self.onStart(2)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" /><Input name="signal1" type="1" type_size="1" nature="1" inner="0" tooltip="First signal to wait." id="2" /><Input name="signal2" type="1" type_size="1" nature="1" inner="0" tooltip="Second signal to wait." id="3" /><Output name="signalsReceived" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when both inputs have been stimulated." id="4" /></Box><Link inputowner="8" indexofinput="2" outputowner="5" indexofoutput="4" /><Link inputowner="8" indexofinput="3" outputowner="6" indexofoutput="4" /><Link inputowner="9" indexofinput="2" outputowner="8" indexofoutput="4" /><Link inputowner="5" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="5" indexofinput="3" outputowner="0" indexofoutput="3" /><Link inputowner="6" indexofinput="2" outputowner="0" indexofoutput="4" /><Link inputowner="6" indexofinput="3" outputowner="0" indexofoutput="5" /><Link inputowner="0" indexofinput="9" outputowner="9" indexofoutput="4" /><Link inputowner="1" indexofinput="3" outputowner="0" indexofoutput="7" /><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="6" /><Link inputowner="9" indexofinput="3" outputowner="1" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Box name="Short Log" id="5" localization="8" tooltip="Enter tooltip here" x="349" y="110"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

    def onLoad(self):
         # Get Filename Logger
        self.SamplingRate = self.getParameter('Sampling Rate')
        self.Frequency = self.getParameter('Frequency')
        self.Buffer = self.getParameter('Buffer')
        self.Frequency_choice = self.getParameter('Unit Fr')
        self.Sampling_choice = self.getParameter('Unit Sr')
        self.NbCycle = self.getParameter('Nb Cycle')


        #Frequency
        if self.Frequency_choice=='minutes':
            self.frequency_value = self.Frequency * 60
        elif self.Frequency_choice == 'hours':
            self.frequency_value = self.Frequency * 3600
        elif self.Frequency_choice == 'Days':
            self.frequency_value = self.Frequency * 86400

        #Sampling
        if self.Sampling_choice == 'Millisecondes':
            self.sampling_value = self.SamplingRate * 0.001
        elif self.Sampling_choice == 'Minutes':
            self.sampling_value = self.SamplingRate *60
        elif self.Sampling_choice == 'Hours':
            self.sampling_value = self.SamplingRate * 3600
        else:
            self.sampling_value = self.SamplingRate
        pass

        self.memory_proxy.insertData("testbench/config/log/short/frequency",self.frequency_value)
        self.memory_proxy.insertData("testbench/config/log/short/sampling",self.sampling_value)
        self.memory_proxy.insertData("testbench/config/log/short/Buffer",self.Buffer)
        self.memory_proxy.insertData("testbench/config/log/short/cycle", self.NbCycle)

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        # Insert Data in Almemory
        #Data Frequency
        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Sampling Rate" inherits_from_parent="0" content_type="1" value="10" default_value="2" min="0" max="100" tooltip="" id="5" /><Parameter name="Unit Sr" inherits_from_parent="0" content_type="3" value="Milliseconds" default_value="Hours" custom_choice="0" tooltip="" id="6"><Choice value="Milliseconds" /><Choice value="Seconds" /><Choice value="Minutes" /><Choice value="Hours" /></Parameter><Parameter name="Frequency" inherits_from_parent="0" content_type="1" value="1" default_value="0" min="0" max="100" tooltip="" id="7" /><Parameter name="Unit Fr" inherits_from_parent="0" content_type="3" value="hours" default_value="Days" custom_choice="0" tooltip="" id="8"><Choice value="minutes" /><Choice value="hours" /><Choice value="Days" /></Parameter><Parameter name="Buffer" inherits_from_parent="0" content_type="1" value="10000" default_value="10000" min="1" max="100000" tooltip="" id="9" /><Parameter name="Nb Cycle" inherits_from_parent="0" content_type="1" value="3" default_value="0" min="0" max="10" tooltip="" id="10" /></Box><Box name="Carac Log" id="6" localization="8" tooltip="Enter tooltip here" x="349" y="204"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

    def onLoad(self):
         # Get Filename Logger
        self.SamplingRate = self.getParameter('Sampling Rate')
        self.Frequency = self.getParameter('Frequency')
        self.Buffer = self.getParameter('Buffer')
        self.Frequency_choice = self.getParameter('Unit Fr')
        self.Sampling_choice = self.getParameter('Unit Sr')
        self.Nb_cycle = self.getParameter('Nb cycle')


        #Frequency
        if self.Frequency_choice=='minutes':
            self.frequency_value = self.Frequency * 60
        elif self.Frequency_choice == 'hours':
            self.frequency_value = self.Frequency * 3600
        elif self.Frequency_choice == 'Days':
            self.frequency_value = self.Frequency * 86400

        #Sampling
        if self.Sampling_choice == 'Millisecondes':
            self.sampling_value = self.SamplingRate * 0.001
        elif self.Sampling_choice == 'Minutes':
            self.sampling_value = self.SamplingRate *60
        elif self.Sampling_choice == 'Hours':
            self.sampling_value = self.SamplingRate * 3600
        else:
            self.sampling_value = self.SamplingRate

        pass

        self.memory_proxy.insertData("testbench/config/log/carac/frequency",self.frequency_value)
        self.memory_proxy.insertData("testbench/config/log/carac/sampling",self.sampling_value)
        self.memory_proxy.insertData("testbench/config/log/carac/Buffer",self.Buffer)
        self.memory_proxy.insertData("testbench/config/log/carac/cycle",self.Nb_cycle)

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        # Insert Data in Almemory
        #Data Frequency
        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Sampling Rate" inherits_from_parent="0" content_type="1" value="10" default_value="2" min="0" max="100" tooltip="" id="5" /><Parameter name="Unit Sr" inherits_from_parent="0" content_type="3" value="Seconds" default_value="Hours" custom_choice="0" tooltip="" id="6"><Choice value="Milliseconds" /><Choice value="Seconds" /><Choice value="Minutes" /><Choice value="Hours" /></Parameter><Parameter name="Frequency" inherits_from_parent="0" content_type="1" value="1" default_value="0" min="0" max="100" tooltip="" id="7" /><Parameter name="Unit Fr" inherits_from_parent="0" content_type="3" value="hours" default_value="Days" custom_choice="0" tooltip="" id="8"><Choice value="minutes" /><Choice value="hours" /><Choice value="Days" /></Parameter><Parameter name="Buffer" inherits_from_parent="0" content_type="1" value="10000" default_value="10000" min="1" max="100000" tooltip="" id="9" /><Parameter name="Nb cycle" inherits_from_parent="0" content_type="1" value="1" default_value="1" min="1" max="10" tooltip="" id="10" /></Box><Box name="Temperature Value" id="3" localization="8" tooltip="Enter tooltip here" x="492" y="244"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

        self.joint_list = ["HeadPitch","HeadYaw","LShoulderPitch","RShoulderPitch","LShoulderRoll","RShoulderRoll","LElbowRoll","RElbowRoll","LElbowYaw","RElbowYaw","LWristYaw","RWristYaw","LHand","RHand","HipPitch","HipRoll","KneePitch","WheelB","WheelFL","WheelFR"]


    def onLoad(self):
        # Get Config Temp
        for joint in self.joint_list:
            value_max = self.getParameter(joint + '_Max')
            value_min = self.getParameter(joint + '_Min')
            self.memory_proxy.insertData("testbench/config/security/temp/" + joint + "/TMax", value_max)
            self.memory_proxy.insertData("testbench/config/security/temp/" + joint + "/TMin", value_min)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):


        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="HeadPitch_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="5" /><Parameter name="HeadPitch_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="6" /><Parameter name="HeadYaw_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="7" /><Parameter name="HeadYaw_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="8" /><Parameter name="LShoulderPitch_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="9" /><Parameter name="LShoulderPitch_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="10" /><Parameter name="RShoulderPitch_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="11" /><Parameter name="RShoulderPitch_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="12" /><Parameter name="LShoulderRoll_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="13" /><Parameter name="LShoulderRoll_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="14" /><Parameter name="RShoulderRoll_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="15" /><Parameter name="RShoulderRoll_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="16" /><Parameter name="LElbowRoll_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="17" /><Parameter name="LElbowRoll_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="18" /><Parameter name="RElbowRoll_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="19" /><Parameter name="RElbowRoll_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="20" /><Parameter name="LElbowYaw_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="21" /><Parameter name="LElbowYaw_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="22" /><Parameter name="RElbowYaw_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="23" /><Parameter name="RElbowYaw_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="24" /><Parameter name="LWristYaw_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="25" /><Parameter name="LWristYaw_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="26" /><Parameter name="RWristYaw_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="27" /><Parameter name="RWristYaw_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="28" /><Parameter name="LHand_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="29" /><Parameter name="LHand_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="30" /><Parameter name="RHand_Max" inherits_from_parent="0" content_type="1" value="64" default_value="0" min="0" max="100" tooltip="" id="31" /><Parameter name="RHand_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="32" /><Parameter name="HipPitch_Max" inherits_from_parent="0" content_type="1" value="74" default_value="0" min="0" max="100" tooltip="" id="33" /><Parameter name="HipPitch_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="34" /><Parameter name="HipRoll_Max" inherits_from_parent="0" content_type="1" value="74" default_value="0" min="0" max="100" tooltip="" id="35" /><Parameter name="HipRoll_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="36" /><Parameter name="KneePitch_Max" inherits_from_parent="0" content_type="1" value="74" default_value="0" min="0" max="100" tooltip="" id="37" /><Parameter name="KneePitch_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="38" /><Parameter name="WheelB_Max" inherits_from_parent="0" content_type="1" value="74" default_value="0" min="0" max="100" tooltip="" id="39" /><Parameter name="WheelB_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="40" /><Parameter name="WheelFL_Max" inherits_from_parent="0" content_type="1" value="74" default_value="0" min="0" max="100" tooltip="" id="41" /><Parameter name="WheelFL_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="42" /><Parameter name="WheelFR_Max" inherits_from_parent="0" content_type="1" value="74" default_value="0" min="0" max="100" tooltip="" id="43" /><Parameter name="WheelFR_Min" inherits_from_parent="0" content_type="1" value="55" default_value="0" min="0" max="100" tooltip="" id="44" /></Box><Box name="Delta Value" id="7" localization="8" tooltip="Enter tooltip here" x="492" y="339"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

        self.joint_list = ["HeadPitch","HeadYaw","LShoulderPitch","RShoulderPitch","LShoulderRoll","RShoulderRoll","LElbowRoll","RElbowRoll","LElbowYaw","RElbowYaw","LWristYaw","RWristYaw","LHand","RHand","HipPitch","HipRoll","KneePitch","WheelB","WheelFL","WheelFR"]


    def onLoad(self):
        for joint in self.joint_list:
            value = self.getParameter(joint)
            self.memory_proxy.insertData("testbench/config/security/delta/" + joint + "/value", value)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):

        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="HeadPitch" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="5" /><Parameter name="HeadYaw" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="6" /><Parameter name="LShoulderPitch" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="7" /><Parameter name="RShoulderPitch" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="8" /><Parameter name="LShoulderRoll" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="9" /><Parameter name="RShoulderRoll" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="10" /><Parameter name="LElbowRoll" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="11" /><Parameter name="RElbowRoll" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="12" /><Parameter name="LElbowYaw" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="13" /><Parameter name="RElbowYaw" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="14" /><Parameter name="LWristYaw" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="15" /><Parameter name="RWristYaw" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="16" /><Parameter name="LHand" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="17" /><Parameter name="RHand" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="18" /><Parameter name="HipPitch" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="19" /><Parameter name="HipRoll" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="20" /><Parameter name="KneePitch" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="21" /><Parameter name="WheelB" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="22" /><Parameter name="WheelFL" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="23" /><Parameter name="WheelFR" inherits_from_parent="0" content_type="2" value="1" default_value="0" min="0" max="1" tooltip="" id="24" /></Box><Box name="Wait For Signals" id="8" localization="8" tooltip="Wait for both inputs to be stimulated before stimulating its output." x="622" y="259"><bitmap>media/images/box/wait.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        try: # disable autoBind
          GeneratedClass.__init__(self, False)
        except TypeError: # if NAOqi < 1.14
          GeneratedClass.__init__( self )

    def onLoad(self):
        self.ok = [False]*2

    def onUnload(self):
        #puts code for box cleanup here
        ""

    def onStart(self, nInput):
        self.ok[nInput-1] = True
        bOutput = True
        for bOk in self.ok:
            bOutput = bOutput and bOk
        if( bOutput ):
            self.ok = [False]*2
            self.signalsReceived()

    def onInput_signal1(self):
        self.onStart(1)

    def onInput_signal2(self):
        self.onStart(2)]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" /><Input name="signal1" type="1" type_size="1" nature="1" inner="0" tooltip="First signal to wait." id="2" /><Input name="signal2" type="1" type_size="1" nature="1" inner="0" tooltip="Second signal to wait." id="3" /><Output name="signalsReceived" type="1" type_size="1" nature="2" inner="0" tooltip="Signal sent when both inputs have been stimulated." id="4" /></Box><Box name="Bootloader Security" id="9" localization="8" tooltip="Enter tooltip here" x="355" y="502"><bitmap>media/images/box/print.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

    def onLoad(self):
        # Get Filename Logger
        self.Frequency = self.getParameter('Frequency')
        self.Frequency_choice = self.getParameter('Unit Fr')

        self.listCheckBoard = []

        if self.getParameter('Left_HandBoard'):
            self.listCheckBoard += ['LeftHandBoard']
        if self.getParameter('Right_HandBoard'):
            self.listCheckBoard += ['RightHandBoard']
        if self.getParameter('Left_ArmBoard'):
            self.listCheckBoard += ['LeftArmBoard']
        if self.getParameter('Right_ArmBoard'):
            self.listCheckBoard += ['RightArmBoard']

        self.memory_proxy.insertData("testbench/config/security/bootloader/cardlist",self.listCheckBoard)

        #Frequency
        if self.Frequency_choice=='minutes':
            self.frequency_value = self.Frequency * 60
        elif self.Frequency_choice == 'hours':
            self.frequency_value = self.Frequency * 3600
        elif self.Frequency_choice == 'Days':
            self.frequency_value = self.Frequency * 86400
        elif self.Frequency_choice == 'seconds':
            self.frequency_value = self.Frequency

        self.memory_proxy.insertData("testbench/config/security/bootloader/sampling",self.frequency_value)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        # Insert Data in Almemory
        #Data Frequency
        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Frequency" inherits_from_parent="0" content_type="1" value="10" default_value="0" min="0" max="100" tooltip="" id="5" /><Parameter name="Unit Fr" inherits_from_parent="0" content_type="3" value="minutes" default_value="seconds" custom_choice="0" tooltip="" id="6"><Choice value="minutes" /><Choice value="hours" /><Choice value="Days" /><Choice value="seconds" /></Parameter><Parameter name="Left_HandBoard" inherits_from_parent="0" content_type="0" value="0" default_value="0" tooltip="" id="7" /><Parameter name="Right_HandBoard" inherits_from_parent="0" content_type="0" value="0" default_value="0" tooltip="" id="8" /><Parameter name="Left_ArmBoard" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="9" /><Parameter name="Right_ArmBoard" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="" id="10" /></Box><Box name="Target Value" id="11" localization="8" tooltip="Enter tooltip here" x="348" y="609"><bitmap>media/images/box/folder.png</bitmap><script language="4"><content><![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        # Create ALMemory Proxy
        self.memory_proxy = naoqi.ALProxy("ALMemory","127.0.0.1",9559)

    def onLoad(self):
        # Get Target Value
        self.TargetValue1 = self.getParameter('Target Value1')
        self.TargetValue2 = self.getParameter('Target Value2')
        self.TargetValue3 = self.getParameter('Target Value3')
        self.TargetValue4 = self.getParameter('Target Value4')
        self.TargetValue5 = self.getParameter('Target Value5')

        # Data Target Value
        self.memory_proxy.insertData("testbench/config/Target/Value1",self.TargetValue1)
        self.memory_proxy.insertData("testbench/config/Target/Value2",self.TargetValue2)
        self.memory_proxy.insertData("testbench/config/Target/Value3",self.TargetValue3)
        self.memory_proxy.insertData("testbench/config/Target/Value4",self.TargetValue4)
        self.memory_proxy.insertData("testbench/config/Target/Value5",self.TargetValue5)
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        self.onStopped() #activate the output of the box
        pass

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped]]></content></script><Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" /><Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" /><Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" /><Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" /><Parameter name="Target Value1" inherits_from_parent="0" content_type="3" value="1156000" default_value="0" custom_choice="0" tooltip="" id="5" /><Parameter name="Target Value2" inherits_from_parent="0" content_type="3" value="1156000" default_value="0" custom_choice="0" tooltip="" id="6" /><Parameter name="Target Value3" inherits_from_parent="0" content_type="3" value="0" default_value="0" custom_choice="0" tooltip="" id="7" /><Parameter name="Target Value4" inherits_from_parent="0" content_type="3" value="0" default_value="0" custom_choice="0" tooltip="" id="8" /><Parameter name="Target Value5" inherits_from_parent="0" content_type="3" value="0" default_value="0" custom_choice="0" tooltip="" id="9" /></Box><Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="4" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="10" indexofinput="2" outputowner="2" indexofoutput="4" /><Link inputowner="10" indexofinput="6" outputowner="1" indexofoutput="4" /><Link inputowner="0" indexofinput="4" outputowner="10" indexofoutput="9" /><Link inputowner="5" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="10" indexofinput="3" outputowner="5" indexofoutput="4" /><Link inputowner="6" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="10" indexofinput="4" outputowner="6" indexofoutput="4" /><Link inputowner="3" indexofinput="2" outputowner="4" indexofoutput="4" /><Link inputowner="7" indexofinput="2" outputowner="4" indexofoutput="4" /><Link inputowner="8" indexofinput="2" outputowner="3" indexofoutput="4" /><Link inputowner="8" indexofinput="3" outputowner="7" indexofoutput="4" /><Link inputowner="10" indexofinput="5" outputowner="8" indexofoutput="4" /><Link inputowner="9" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="10" indexofinput="7" outputowner="9" indexofoutput="4" /><Link inputowner="11" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="10" indexofinput="8" outputowner="11" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box><Link inputowner="4" indexofinput="2" outputowner="0" indexofoutput="2" /><Link inputowner="1" indexofinput="2" outputowner="4" indexofoutput="4" /></Diagram></BehaviorKeyframe></BehaviorLayer></Timeline></Box></ChoregrapheProject>